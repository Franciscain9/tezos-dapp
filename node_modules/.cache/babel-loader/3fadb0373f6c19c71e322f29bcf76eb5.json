{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst jsonpath_plus_1 = require(\"jsonpath-plus\");\n\nconst TezosMessageUtil_1 = require(\"../../TezosMessageUtil\");\n\nconst TezosNodeReader_1 = require(\"../../TezosNodeReader\");\n\nconst TezosNodeWriter_1 = require(\"../../TezosNodeWriter\");\n\nconst TezosTypes = __importStar(require(\"../../../../types/tezos/TezosChainTypes\"));\n\nconst TezosContractUtils_1 = require(\"../TezosContractUtils\");\n\nvar SingleAssetTokenHelper;\n\n(function (SingleAssetTokenHelper) {\n  function verifyDestination(server, address) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return TezosContractUtils_1.TezosContractUtils.verifyDestination(server, address, '17aab0975df6139f4ff29be76a67f348');\n    });\n  }\n\n  SingleAssetTokenHelper.verifyDestination = verifyDestination;\n\n  function verifyScript(script) {\n    return TezosContractUtils_1.TezosContractUtils.verifyScript(script, '000');\n  }\n\n  SingleAssetTokenHelper.verifyScript = verifyScript;\n\n  function deployContract(server, signer, keystore, fee, administrator, name, symbol, tokenid, scale, pause = true, supply = 0, gas = 800000, freight = 20000) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const contract = `parameter (or (or (or %admin (or (unit %confirm_admin) (bool %pause)) (address %set_admin)) (or %assets (or (pair %balance_of (list %requests (pair (address %owner) (nat %token_id))) (contract %callback (list (pair (pair %request (address %owner) (nat %token_id)) (nat %balance))))) (contract %token_metadata_registry address)) (or (list %transfer (pair (address %from_) (list %txs (pair (address %to_) (pair (nat %token_id) (nat %amount)))))) (list %update_operators (or (pair %add_operator (address %owner) (address %operator)) (pair %remove_operator (address %owner) (address %operator))))))) (or %tokens (list %burn_tokens (pair (nat %amount) (address %owner))) (list %mint_tokens (pair (nat %amount) (address %owner))))) ;\n            storage (pair (pair %admin (pair (address %admin) (bool %paused)) (option %pending_admin address)) (pair %assets (pair (big_map %ledger address nat) (big_map %operators (pair address address) unit)) (pair (big_map %token_metadata nat (pair (nat %token_id) (pair (string %symbol) (pair (string %name) (pair (nat %decimals) (map %extras string string)))))) (nat %total_supply)))) ;\n            code { PUSH string \"FA2_TOKEN_UNDEFINED\" ; PUSH string \"FA2_INSUFFICIENT_BALANCE\" ; LAMBDA (pair address address) (pair address address) { DUP ; CAR ; DIG 1 ; DUP ; DUG 2 ; CDR ; PAIR ; DIP { DROP } } ; LAMBDA (pair address (big_map address nat)) nat { DUP ; CDR ; DIG 1 ; DUP ; DUG 2 ; CAR ; GET ; IF_NONE { PUSH nat 0 } { DUP ; DIP { DROP } } ; DIP { DROP } } ; DUP ; LAMBDA (pair (lambda (pair address (big_map address nat)) nat) (pair (pair address nat) (big_map address nat))) (big_map address nat) { DUP ; CAR ; SWAP ; CDR ; DUP ; CAR ; CAR ; DIG 1 ; DUP ; DUG 2 ; CDR ; DUP ; DIG 2 ; DUP ; DUG 3 ; PAIR ; DIG 4 ; DUP ; DUG 5 ; SWAP ; EXEC ; DIG 3 ; DUP ; DUG 4 ; CAR ; CDR ; DIG 1 ; DUP ; DUG 2 ; ADD ; DIG 2 ; DUP ; DUG 3 ; DIG 1 ; DUP ; DUG 2 ; SOME ; DIG 5 ; DUP ; DUG 6 ; UPDATE ; DIP { DROP 6 } } ; SWAP ; APPLY ; DIP { DIP { DIP { DUP } ; SWAP } ; DUP ; DIP { PAIR } ; SWAP } ; SWAP ; LAMBDA (pair (pair (lambda (pair address (big_map address nat)) nat) string) (pair (pair address nat) (big_map address nat))) (big_map address nat) { DUP ; CAR ; SWAP ; CDR ; DIP { DUP ; CDR ; SWAP ; CAR } ; DUP ; CAR ; CAR ; DIG 1 ; DUP ; DUG 2 ; CDR ; DUP ; DIG 2 ; DUP ; DUG 3 ; PAIR ; DIG 4 ; DUP ; DUG 5 ; SWAP ; EXEC ; DIG 3 ; DUP ; DUG 4 ; CAR ; CDR ; DIG 1 ; DUP ; DUG 2 ; SUB ; ISNAT ; IF_NONE { DIG 5 ; DUP ; DUG 6 ; FAILWITH } { PUSH nat 0 ; DIG 1 ; DUP ; DUG 2 ; COMPARE ; EQ ; IF { DIG 2 ; DUP ; DUG 3 ; DIG 4 ; DUP ; DUG 5 ; NONE nat ; SWAP ; UPDATE } { DIG 2 ; DUP ; DUG 3 ; DIG 1 ; DUP ; DUG 2 ; SOME ; DIG 5 ; DUP ; DUG 6 ; UPDATE } ; DIP { DROP } } ; DIP { DROP 6 } } ; SWAP ; APPLY ; LAMBDA (list (pair nat address)) nat { PUSH nat 0 ; DIG 1 ; DUP ; DUG 2 ; ITER { SWAP ; PAIR ; DUP ; CDR ; CAR ; DIG 1 ; DUP ; DUG 2 ; CAR ; ADD ; DIP { DROP } } ; DIP { DROP } } ; LAMBDA (pair (pair address bool) (option address)) unit { DUP ; CAR ; CAR ; SENDER ; COMPARE ; NEQ ; IF { PUSH string \"NOT_AN_ADMIN\" ; FAILWITH } { UNIT } ; DIP { DROP } } ; DIG 8 ; DUP ; DUG 9 ; CDR ; DIG 9 ; DUP ; DUG 10 ; CAR ; IF_LEFT { DUP ; IF_LEFT { DIG 2 ; DUP ; DUG 3 ; CAR ; DIG 1 ; DUP ; DUG 2 ; PAIR ; DUP ; CDR ; DIG 1 ; DUP ; DUG 2 ; CAR ; IF_LEFT { DUP ; IF_LEFT { DIG 2 ; DUP ; DUG 3 ; CDR ; IF_NONE { PUSH string \"NO_PENDING_ADMIN\" ; FAILWITH } { DUP ; SENDER ; COMPARE ; EQ ; IF { DIG 3 ; DUP ; DUG 4 ; CAR ; NONE address ; SWAP ; PAIR ; DUP ; CDR ; SWAP ; CAR ; CDR ; SENDER ; PAIR ; PAIR } { PUSH string \"NOT_AN_ADMIN\" ; FAILWITH } ; DIP { DROP } } ; DUP ; NIL operation ; PAIR ; DIP { DROP 2 } } { DIG 2 ; DUP ; DUG 3 ; DIG 8 ; DUP ; DUG 9 ; SWAP ; EXEC ; DIG 3 ; DUP ; DUG 4 ; DIG 2 ; DUP ; DUG 3 ; PAIR ; DUP ; CDR ; DIG 1 ; DUP ; DUG 2 ; CAR ; DIP { DUP ; CDR ; SWAP ; CAR ; CAR } ; SWAP ; PAIR ; PAIR ; DIP { DROP } ; NIL operation ; PAIR ; DIP { DROP 2 } } ; DIP { DROP } } { DIG 1 ; DUP ; DUG 2 ; DIG 7 ; DUP ; DUG 8 ; SWAP ; EXEC ; DIG 2 ; DUP ; DUG 3 ; DIG 2 ; DUP ; DUG 3 ; PAIR ; DUP ; CDR ; DIG 1 ; DUP ; DUG 2 ; CAR ; SOME ; SWAP ; CAR ; PAIR ; DIP { DROP } ; NIL operation ; PAIR ; DIP { DROP 2 } } ; DIP { DROP 2 } ; DIG 3 ; DUP ; DUG 4 ; DIG 1 ; DUP ; DUG 2 ; CDR ; SWAP ; CDR ; SWAP ; PAIR ; DIG 1 ; DUP ; DUG 2 ; CAR ; PAIR ; DIP { DROP 2 } } { DIG 2 ; DUP ; DUG 3 ; CAR ; CAR ; CDR ; IF { PUSH string \"PAUSED\" ; FAILWITH } { UNIT } ; DIG 3 ; DUP ; DUG 4 ; CDR ; DIG 2 ; DUP ; DUG 3 ; PAIR ; DUP ; CDR ; DIG 1 ; DUP ; DUG 2 ; CAR ; IF_LEFT { DUP ; IF_LEFT { DUP ; CAR ; DIG 1 ; DUP ; DUG 2 ; CDR ; PAIR ; DUP ; CDR ; MAP { DUP ; DIP { DROP } } ; DUP ; DIG 2 ; DUP ; DUG 3 ; CAR ; PAIR ; DIP { DROP 2 } ; DIG 3 ; DUP ; DUG 4 ; CAR ; CAR ; DIG 1 ; DUP ; DUG 2 ; PAIR ; DUP ; CAR ; DUP ; CDR ; MAP { PUSH nat 0 ; DIG 1 ; DUP ; DUG 2 ; CDR ; COMPARE ; NEQ ; IF { DIG 19 ; DUP ; DUG 20 ; FAILWITH } { DIG 2 ; DUP ; DUG 3 ; CDR ; DIG 1 ; DUP ; DUG 2 ; CAR ; PAIR ; DIG 17 ; DUP ; DUG 18 ; SWAP ; EXEC ; DIG 1 ; DUP ; DUG 2 ; DIG 1 ; DUP ; DUG 2 ; PAIR ; DUP ; CDR ; CDR ; DIG 1 ; DUP ; DUG 2 ; CDR ; CAR ; PAIR ; DIG 1 ; DUP ; DUG 2 ; CAR ; PAIR ; DUP ; CAR ; DIG 1 ; DUP ; DUG 2 ; CDR ; PAIR ; DIP { DROP 3 } } ; DIP { DROP } } ; DIG 1 ; DUP ; DUG 2 ; CAR ; PUSH mutez 0 ; DIG 2 ; DUP ; DUG 3 ; TRANSFER_TOKENS ; DIP { DROP 3 } ; DIG 4 ; DUP ; DUG 5 ; NIL operation ; DIG 2 ; DUP ; DUG 3 ; CONS ; PAIR ; DIP { DROP 3 } } { DUP ; PUSH mutez 0 ; SELF ; ADDRESS ; TRANSFER_TOKENS ; DIG 3 ; DUP ; DUG 4 ; NIL operation ; DIG 2 ; DUP ; DUG 3 ; CONS ; PAIR ; DIP { DROP 2 } } ; DIP { DROP } } { DUP ; IF_LEFT { DUP ; MAP { DUP ; CDR ; MAP { DUP ; CDR ; CAR ; DIG 1 ; DUP ; DUG 2 ; CAR ; DIG 2 ; DUP ; DUG 3 ; CDR ; CDR ; PAIR ; PAIR ; DIP { DROP } } ; DIG 1 ; DUP ; DUG 2 ; CAR ; PAIR ; DIP { DROP } } ; DUP ; MAP { DUP ; CDR ; MAP { PUSH nat 0 ; DIG 1 ; DUP ; DUG 2 ; CDR ; COMPARE ; NEQ ; IF { DIG 18 ; DUP ; DUG 19 ; FAILWITH } { DUP ; CDR ; DIG 1 ; DUP ; DUG 2 ; CAR ; CDR ; SOME ; DIG 2 ; DUP ; DUG 3 ; CAR ; CAR ; PAIR ; PAIR } ; DIP { DROP } } ; DUP ; DIG 2 ; DUP ; DUG 3 ; CAR ; SOME ; PAIR ; DIP { DROP 2 } } ; SENDER ; DUP ; LAMBDA (pair address (pair address (big_map (pair address address) unit))) unit { DUP ; CAR ; SWAP ; CDR ; DUP ; CAR ; DIG 2 ; DUP ; DUG 3 ; DIG 1 ; DUP ; DUG 2 ; COMPARE ; EQ ; IF { UNIT } { DIG 1 ; DUP ; DUG 2 ; CDR ; DIG 3 ; DUP ; DUG 4 ; DIG 2 ; DUP ; DUG 3 ; PAIR ; MEM ; IF { UNIT } { PUSH string \"FA2_NOT_OPERATOR\" ; FAILWITH } } ; DIP { DROP 3 } } ; SWAP ; APPLY ; DIP { DROP } ; DIG 5 ; DUP ; DUG 6 ; CAR ; CAR ; DIG 6 ; DUP ; DUG 7 ; CAR ; CDR ; PAIR ; DIG 1 ; DUP ; DUG 2 ; DIG 3 ; DUP ; DUG 4 ; PAIR ; PAIR ; DUP ; CDR ; CDR ; DIG 1 ; DUP ; DUG 2 ; CAR ; CAR ; ITER { SWAP ; PAIR ; DUP ; CDR ; DUP ; CAR ; IF_NONE { UNIT } { DIG 3 ; DUP ; DUG 4 ; CDR ; CAR ; DIG 1 ; DUP ; DUG 2 ; PAIR ; DIG 4 ; DUP ; DUG 5 ; CAR ; CDR ; SWAP ; EXEC ; DIP { DROP } } ; DIG 2 ; DUP ; DUG 3 ; CAR ; DIG 2 ; DUP ; DUG 3 ; CDR ; ITER { SWAP ; PAIR ; DUP ; CAR ; DIG 1 ; DUP ; DUG 2 ; CDR ; PUSH nat 0 ; DIG 1 ; DUP ; DUG 2 ; CDR ; COMPARE ; NEQ ; IF { DIG 25 ; DUP ; DUG 26 ; FAILWITH } { DIG 4 ; DUP ; DUG 5 ; CAR ; IF_NONE { DIG 1 ; DUP ; DUG 2 } { DIG 2 ; DUP ; DUG 3 ; DIG 2 ; DUP ; DUG 3 ; CAR ; CAR ; DIG 2 ; DUP ; DUG 3 ; PAIR ; PAIR ; DIG 22 ; DUP ; DUG 23 ; SWAP ; EXEC ; DIP { DROP } } ; DIG 1 ; DUP ; DUG 2 ; CAR ; CDR ; IF_NONE { DUP } { DIG 1 ; DUP ; DUG 2 ; DIG 3 ; DUP ; DUG 4 ; CAR ; CAR ; DIG 2 ; DUP ; DUG 3 ; PAIR ; PAIR ; DIG 24 ; DUP ; DUG 25 ; SWAP ; EXEC ; DIP { DROP } } ; DIP { DROP } } ; DIP { DROP 3 } } ; DIP { DROP 3 } } ; DIP { DROP } ; DIG 6 ; DUP ; DUG 7 ; DIG 1 ; DUP ; DUG 2 ; DIP { DUP ; CDR ; SWAP ; CAR ; CDR } ; PAIR ; PAIR ; NIL operation ; PAIR ; DIP { DROP 5 } } { DUP ; MAP { DUP ; IF_LEFT { DUP ; LEFT (pair (address %owner) (address %operator)) ; DIP { DROP } } { DUP ; RIGHT (pair (address %owner) (address %operator)) ; DIP { DROP } } ; DUP ; IF_LEFT { DUP ; DIG 17 ; DUP ; DUG 18 ; SWAP ; EXEC ; LEFT (pair (address %operator) (address %owner)) ; DIP { DROP } } { DUP ; DIG 17 ; DUP ; DUG 18 ; SWAP ; EXEC ; RIGHT (pair (address %operator) (address %owner)) ; DIP { DROP } } ; DIP { DROP 2 } } ; SENDER ; DIG 4 ; DUP ; DUG 5 ; CAR ; CDR ; DIG 2 ; DUP ; DUG 3 ; ITER { SWAP ; PAIR ; DUP ; CDR ; DIG 2 ; DUP ; DUG 3 ; DIG 1 ; DUP ; DUG 2 ; PAIR ; DUP ; CDR ; DIG 1 ; DUP ; DUG 2 ; CAR ; IF_LEFT { DUP ; DIP { DROP } } { DUP ; DIP { DROP } } ; CDR ; COMPARE ; EQ ; IF { UNIT } { PUSH string \"FA2_NOT_OWNER\" ; FAILWITH } ; DIP { DROP } ; DIG 2 ; DUP ; DUG 3 ; CAR ; DIG 2 ; DUP ; DUG 3 ; PAIR ; DUP ; CDR ; DIG 1 ; DUP ; DUG 2 ; CAR ; IF_LEFT { DIG 1 ; DUP ; DUG 2 ; UNIT ; SOME ; DIG 2 ; DUP ; DUG 3 ; CAR ; DIG 3 ; DUP ; DUG 4 ; CDR ; PAIR ; UPDATE ; DIP { DROP } } { DIG 1 ; DUP ; DUG 2 ; DIG 1 ; DUP ; DUG 2 ; CAR ; DIG 2 ; DUP ; DUG 3 ; CDR ; PAIR ; NONE unit ; SWAP ; UPDATE ; DIP { DROP } } ; DIP { DROP 5 } } ; DIG 5 ; DUP ; DUG 6 ; DIG 1 ; DUP ; DUG 2 ; DIP { DUP ; CDR ; SWAP ; CAR ; CAR } ; SWAP ; PAIR ; PAIR ; NIL operation ; PAIR ; DIP { DROP 4 } } ; DIP { DROP } } ; DIP { DROP 2 } ; DIG 4 ; DUP ; DUG 5 ; DIG 1 ; DUP ; DUG 2 ; CDR ; SWAP ; CAR ; PAIR ; DIG 1 ; DUP ; DUG 2 ; CAR ; PAIR ; DIP { DROP 3 } } ; DIP { DROP } } { DIG 1 ; DUP ; DUG 2 ; CAR ; DIG 3 ; DUP ; DUG 4 ; SWAP ; EXEC ; DIG 2 ; DUP ; DUG 3 ; CDR ; DIG 2 ; DUP ; DUG 3 ; PAIR ; DUP ; CDR ; DIG 1 ; DUP ; DUG 2 ; CAR ; IF_LEFT { DIG 1 ; DUP ; DUG 2 ; DIG 1 ; DUP ; DUG 2 ; PAIR ; DUP ; CAR ; DIG 1 ; DUP ; DUG 2 ; CDR ; DUP ; CAR ; CAR ; DIG 2 ; DUP ; DUG 3 ; PAIR ; DUP ; CDR ; DIG 1 ; DUP ; DUG 2 ; CAR ; ITER { SWAP ; PAIR ; DUP ; CDR ; DIG 1 ; DUP ; DUG 2 ; CAR ; DIG 1 ; DUP ; DUG 2 ; CAR ; DIG 2 ; DUP ; DUG 3 ; CDR ; PAIR ; PAIR ; DIG 15 ; DUP ; DUG 16 ; SWAP ; EXEC ; DIP { DROP 2 } } ; DIP { DROP } ; DIG 2 ; DUP ; DUG 3 ; DIG 12 ; DUP ; DUG 13 ; SWAP ; EXEC ; DUP ; DIG 3 ; DUP ; DUG 4 ; CDR ; CDR ; SUB ; ISNAT ; DUP ; IF_NONE { DIG 18 ; DUP ; DUG 19 ; FAILWITH } { DUP ; DIP { DROP } } ; DIG 4 ; DUP ; DUG 5 ; DIG 4 ; DUP ; DUG 5 ; DIP { DUP ; CDR ; SWAP ; CAR ; CDR } ; PAIR ; PAIR ; DIG 1 ; DUP ; DUG 2 ; DIP { DUP ; CAR ; SWAP ; CDR ; CAR } ; SWAP ; PAIR ; SWAP ; PAIR ; NIL operation ; PAIR ; DIP { DROP 8 } } { DIG 1 ; DUP ; DUG 2 ; DIG 1 ; DUP ; DUG 2 ; PAIR ; DUP ; CAR ; DIG 1 ; DUP ; DUG 2 ; CDR ; DUP ; CAR ; CAR ; DIG 2 ; DUP ; DUG 3 ; PAIR ; DUP ; CDR ; DIG 1 ; DUP ; DUG 2 ; CAR ; ITER { SWAP ; PAIR ; DUP ; CDR ; DIG 1 ; DUP ; DUG 2 ; CAR ; DIG 1 ; DUP ; DUG 2 ; CAR ; DIG 2 ; DUP ; DUG 3 ; CDR ; PAIR ; PAIR ; DIG 16 ; DUP ; DUG 17 ; SWAP ; EXEC ; DIP { DROP 2 } } ; DIP { DROP } ; DIG 2 ; DUP ; DUG 3 ; DIG 12 ; DUP ; DUG 13 ; SWAP ; EXEC ; DIG 2 ; DUP ; DUG 3 ; DIG 2 ; DUP ; DUG 3 ; DIP { DUP ; CDR ; SWAP ; CAR ; CDR } ; PAIR ; PAIR ; DIG 1 ; DUP ; DUG 2 ; DIG 4 ; DUP ; DUG 5 ; CDR ; CDR ; ADD ; DIP { DUP ; CAR ; SWAP ; CDR ; CAR } ; SWAP ; PAIR ; SWAP ; PAIR ; DUP ; NIL operation ; PAIR ; DIP { DROP 7 } } ; DIP { DROP 2 } ; DIG 3 ; DUP ; DUG 4 ; DIG 1 ; DUP ; DUG 2 ; CDR ; SWAP ; CAR ; PAIR ; DIG 1 ; DUP ; DUG 2 ; CAR ; PAIR ; DIP { DROP 3 } } ; DIP { DROP 10 } } ; `;\n      const storage = `( Pair ( Pair ( Pair \"${administrator}\" ${pause ? 'True' : 'False'} ) None ) ( Pair ( Pair { } { } ) ( Pair { Elt ${tokenid} ( Pair ${tokenid} ( Pair \"${symbol}\" ( Pair \"${name}\" ( Pair ${scale} { } ) ) ) ) } ${supply} ) ) )`;\n      const nodeResult = yield TezosNodeWriter_1.TezosNodeWriter.sendContractOriginationOperation(server, signer, keystore, 0, undefined, fee, freight, gas, contract, storage, TezosTypes.TezosParameterFormat.Michelson);\n      return TezosContractUtils_1.TezosContractUtils.clearRPCOperationGroupHash(nodeResult['operationGroupID']);\n    });\n  }\n\n  SingleAssetTokenHelper.deployContract = deployContract;\n\n  function getSimpleStorage(server, address) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const storageResult = yield TezosNodeReader_1.TezosNodeReader.getContractStorage(server, address);\n      return {\n        administrator: jsonpath_plus_1.JSONPath({\n          path: '$.args[0].args[0].args[0].string',\n          json: storageResult\n        })[0],\n        paused: jsonpath_plus_1.JSONPath({\n          path: '$.args[0].args[0].args[1].prim',\n          json: storageResult\n        })[0].toString().toLowerCase().startsWith('t'),\n        pendingAdmin: jsonpath_plus_1.JSONPath({\n          path: '$.args[0].args[1].prim',\n          json: storageResult\n        })[0],\n        balanceMap: Number(jsonpath_plus_1.JSONPath({\n          path: '$.args[1].args[0].args[0].int',\n          json: storageResult\n        })[0]),\n        operatorMap: Number(jsonpath_plus_1.JSONPath({\n          path: '$.args[1].args[0].args[1].int',\n          json: storageResult\n        })[0]),\n        metadataMap: Number(jsonpath_plus_1.JSONPath({\n          path: '$.args[1].args[1].args[0].int',\n          json: storageResult\n        })[0]),\n        supply: Number(jsonpath_plus_1.JSONPath({\n          path: '$.args[1].args[1].args[1].int',\n          json: storageResult\n        })[0])\n      };\n    });\n  }\n\n  SingleAssetTokenHelper.getSimpleStorage = getSimpleStorage;\n\n  function getTokenDefinition(server, mapid, token = 0) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const packedKey = TezosMessageUtil_1.TezosMessageUtils.encodeBigMapKey(Buffer.from(TezosMessageUtil_1.TezosMessageUtils.writePackedData(token, 'nat'), 'hex'));\n      const mapResult = yield TezosNodeReader_1.TezosNodeReader.getValueForBigMapKey(server, mapid, packedKey);\n\n      if (mapResult === undefined) {\n        throw new Error(`Map ${mapid} does not contain a record for token ${token}`);\n      }\n\n      return {\n        tokenid: Number(jsonpath_plus_1.JSONPath({\n          path: '$.args[0].int',\n          json: mapResult\n        })[0]),\n        symbol: jsonpath_plus_1.JSONPath({\n          path: '$.args[1].args[0].string',\n          json: mapResult\n        })[0],\n        name: jsonpath_plus_1.JSONPath({\n          path: '$.args[1].args[1].args[0].string',\n          json: mapResult\n        })[0],\n        scale: Number(jsonpath_plus_1.JSONPath({\n          path: '$.args[1].args[1].args[1].args[0].int',\n          json: mapResult\n        })[0])\n      };\n    });\n  }\n\n  SingleAssetTokenHelper.getTokenDefinition = getTokenDefinition;\n\n  function activate(server, address, signer, keystore, fee, gas = 800000, freight = 20000) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const entryPoint = 'pause';\n      const parameters = 'False';\n      const nodeResult = yield TezosNodeWriter_1.TezosNodeWriter.sendContractInvocationOperation(server, signer, keystore, address, 0, fee, freight, gas, entryPoint, parameters, TezosTypes.TezosParameterFormat.Michelson);\n      return TezosContractUtils_1.TezosContractUtils.clearRPCOperationGroupHash(nodeResult.operationGroupID);\n    });\n  }\n\n  SingleAssetTokenHelper.activate = activate;\n\n  function deactivate(server, address, signer, keystore, fee, gas = 800000, freight = 20000) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const entryPoint = 'pause';\n      const parameters = 'True';\n      const nodeResult = yield TezosNodeWriter_1.TezosNodeWriter.sendContractInvocationOperation(server, signer, keystore, address, 0, fee, freight, gas, entryPoint, parameters, TezosTypes.TezosParameterFormat.Michelson);\n      return TezosContractUtils_1.TezosContractUtils.clearRPCOperationGroupHash(nodeResult.operationGroupID);\n    });\n  }\n\n  SingleAssetTokenHelper.deactivate = deactivate;\n\n  function mint(server, address, signer, keystore, fee, issue, gas = 800000, freight = 20000) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const entryPoint = 'mint_tokens';\n      const parameters = `{ ${issue.map(i => '( Pair ' + i.balance + ' \"' + i.address + '\" )').join(' ; ')} }`;\n      const nodeResult = yield TezosNodeWriter_1.TezosNodeWriter.sendContractInvocationOperation(server, signer, keystore, address, 0, fee, freight, gas, entryPoint, parameters, TezosTypes.TezosParameterFormat.Michelson);\n      return TezosContractUtils_1.TezosContractUtils.clearRPCOperationGroupHash(nodeResult.operationGroupID);\n    });\n  }\n\n  SingleAssetTokenHelper.mint = mint;\n\n  function transfer(server, address, signer, keystore, fee, source, transfers, gas = 800000, freight = 20000) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const entryPoint = 'transfer';\n      const parameters = `{ Pair \"${source}\" { ${transfers.map(t => '( Pair \"' + t.address + '\" ( Pair ' + t.tokenid + ' ' + t.balance + ' ) )').join(' ; ')} } }`;\n      const nodeResult = yield TezosNodeWriter_1.TezosNodeWriter.sendContractInvocationOperation(server, signer, keystore, address, 0, fee, freight, gas, entryPoint, parameters, TezosTypes.TezosParameterFormat.Michelson);\n      return TezosContractUtils_1.TezosContractUtils.clearRPCOperationGroupHash(nodeResult.operationGroupID);\n    });\n  }\n\n  SingleAssetTokenHelper.transfer = transfer;\n\n  function getAccountBalance(server, mapid, account) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const packedKey = TezosMessageUtil_1.TezosMessageUtils.encodeBigMapKey(Buffer.from(TezosMessageUtil_1.TezosMessageUtils.writePackedData(account, 'address'), 'hex'));\n      const mapResult = yield TezosNodeReader_1.TezosNodeReader.getValueForBigMapKey(server, mapid, packedKey);\n\n      if (mapResult === undefined) {\n        throw new Error(`Map ${mapid} does not contain a record for ${account}`);\n      }\n\n      const jsonresult = jsonpath_plus_1.JSONPath({\n        path: '$.int',\n        json: mapResult\n      });\n      return Number(jsonresult[0]);\n    });\n  }\n\n  SingleAssetTokenHelper.getAccountBalance = getAccountBalance;\n})(SingleAssetTokenHelper = exports.SingleAssetTokenHelper || (exports.SingleAssetTokenHelper = {}));","map":{"version":3,"sources":["../../../../../src/chain/tezos/contracts/tzip12/SingleAssetTokenHelper.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst jsonpath_plus_1 = require(\"jsonpath-plus\");\nconst TezosMessageUtil_1 = require(\"../../TezosMessageUtil\");\nconst TezosNodeReader_1 = require(\"../../TezosNodeReader\");\nconst TezosNodeWriter_1 = require(\"../../TezosNodeWriter\");\nconst TezosTypes = __importStar(require(\"../../../../types/tezos/TezosChainTypes\"));\nconst TezosContractUtils_1 = require(\"../TezosContractUtils\");\nvar SingleAssetTokenHelper;\n(function (SingleAssetTokenHelper) {\n    function verifyDestination(server, address) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return TezosContractUtils_1.TezosContractUtils.verifyDestination(server, address, '17aab0975df6139f4ff29be76a67f348');\n        });\n    }\n    SingleAssetTokenHelper.verifyDestination = verifyDestination;\n    function verifyScript(script) {\n        return TezosContractUtils_1.TezosContractUtils.verifyScript(script, '000');\n    }\n    SingleAssetTokenHelper.verifyScript = verifyScript;\n    function deployContract(server, signer, keystore, fee, administrator, name, symbol, tokenid, scale, pause = true, supply = 0, gas = 800000, freight = 20000) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const contract = `parameter (or (or (or %admin (or (unit %confirm_admin) (bool %pause)) (address %set_admin)) (or %assets (or (pair %balance_of (list %requests (pair (address %owner) (nat %token_id))) (contract %callback (list (pair (pair %request (address %owner) (nat %token_id)) (nat %balance))))) (contract %token_metadata_registry address)) (or (list %transfer (pair (address %from_) (list %txs (pair (address %to_) (pair (nat %token_id) (nat %amount)))))) (list %update_operators (or (pair %add_operator (address %owner) (address %operator)) (pair %remove_operator (address %owner) (address %operator))))))) (or %tokens (list %burn_tokens (pair (nat %amount) (address %owner))) (list %mint_tokens (pair (nat %amount) (address %owner))))) ;\n            storage (pair (pair %admin (pair (address %admin) (bool %paused)) (option %pending_admin address)) (pair %assets (pair (big_map %ledger address nat) (big_map %operators (pair address address) unit)) (pair (big_map %token_metadata nat (pair (nat %token_id) (pair (string %symbol) (pair (string %name) (pair (nat %decimals) (map %extras string string)))))) (nat %total_supply)))) ;\n            code { PUSH string \"FA2_TOKEN_UNDEFINED\" ; PUSH string \"FA2_INSUFFICIENT_BALANCE\" ; LAMBDA (pair address address) (pair address address) { DUP ; CAR ; DIG 1 ; DUP ; DUG 2 ; CDR ; PAIR ; DIP { DROP } } ; LAMBDA (pair address (big_map address nat)) nat { DUP ; CDR ; DIG 1 ; DUP ; DUG 2 ; CAR ; GET ; IF_NONE { PUSH nat 0 } { DUP ; DIP { DROP } } ; DIP { DROP } } ; DUP ; LAMBDA (pair (lambda (pair address (big_map address nat)) nat) (pair (pair address nat) (big_map address nat))) (big_map address nat) { DUP ; CAR ; SWAP ; CDR ; DUP ; CAR ; CAR ; DIG 1 ; DUP ; DUG 2 ; CDR ; DUP ; DIG 2 ; DUP ; DUG 3 ; PAIR ; DIG 4 ; DUP ; DUG 5 ; SWAP ; EXEC ; DIG 3 ; DUP ; DUG 4 ; CAR ; CDR ; DIG 1 ; DUP ; DUG 2 ; ADD ; DIG 2 ; DUP ; DUG 3 ; DIG 1 ; DUP ; DUG 2 ; SOME ; DIG 5 ; DUP ; DUG 6 ; UPDATE ; DIP { DROP 6 } } ; SWAP ; APPLY ; DIP { DIP { DIP { DUP } ; SWAP } ; DUP ; DIP { PAIR } ; SWAP } ; SWAP ; LAMBDA (pair (pair (lambda (pair address (big_map address nat)) nat) string) (pair (pair address nat) (big_map address nat))) (big_map address nat) { DUP ; CAR ; SWAP ; CDR ; DIP { DUP ; CDR ; SWAP ; CAR } ; DUP ; CAR ; CAR ; DIG 1 ; DUP ; DUG 2 ; CDR ; DUP ; DIG 2 ; DUP ; DUG 3 ; PAIR ; DIG 4 ; DUP ; DUG 5 ; SWAP ; EXEC ; DIG 3 ; DUP ; DUG 4 ; CAR ; CDR ; DIG 1 ; DUP ; DUG 2 ; SUB ; ISNAT ; IF_NONE { DIG 5 ; DUP ; DUG 6 ; FAILWITH } { PUSH nat 0 ; DIG 1 ; DUP ; DUG 2 ; COMPARE ; EQ ; IF { DIG 2 ; DUP ; DUG 3 ; DIG 4 ; DUP ; DUG 5 ; NONE nat ; SWAP ; UPDATE } { DIG 2 ; DUP ; DUG 3 ; DIG 1 ; DUP ; DUG 2 ; SOME ; DIG 5 ; DUP ; DUG 6 ; UPDATE } ; DIP { DROP } } ; DIP { DROP 6 } } ; SWAP ; APPLY ; LAMBDA (list (pair nat address)) nat { PUSH nat 0 ; DIG 1 ; DUP ; DUG 2 ; ITER { SWAP ; PAIR ; DUP ; CDR ; CAR ; DIG 1 ; DUP ; DUG 2 ; CAR ; ADD ; DIP { DROP } } ; DIP { DROP } } ; LAMBDA (pair (pair address bool) (option address)) unit { DUP ; CAR ; CAR ; SENDER ; COMPARE ; NEQ ; IF { PUSH string \"NOT_AN_ADMIN\" ; FAILWITH } { UNIT } ; DIP { DROP } } ; DIG 8 ; DUP ; DUG 9 ; CDR ; DIG 9 ; DUP ; DUG 10 ; CAR ; IF_LEFT { DUP ; IF_LEFT { DIG 2 ; DUP ; DUG 3 ; CAR ; DIG 1 ; DUP ; DUG 2 ; PAIR ; DUP ; CDR ; DIG 1 ; DUP ; DUG 2 ; CAR ; IF_LEFT { DUP ; IF_LEFT { DIG 2 ; DUP ; DUG 3 ; CDR ; IF_NONE { PUSH string \"NO_PENDING_ADMIN\" ; FAILWITH } { DUP ; SENDER ; COMPARE ; EQ ; IF { DIG 3 ; DUP ; DUG 4 ; CAR ; NONE address ; SWAP ; PAIR ; DUP ; CDR ; SWAP ; CAR ; CDR ; SENDER ; PAIR ; PAIR } { PUSH string \"NOT_AN_ADMIN\" ; FAILWITH } ; DIP { DROP } } ; DUP ; NIL operation ; PAIR ; DIP { DROP 2 } } { DIG 2 ; DUP ; DUG 3 ; DIG 8 ; DUP ; DUG 9 ; SWAP ; EXEC ; DIG 3 ; DUP ; DUG 4 ; DIG 2 ; DUP ; DUG 3 ; PAIR ; DUP ; CDR ; DIG 1 ; DUP ; DUG 2 ; CAR ; DIP { DUP ; CDR ; SWAP ; CAR ; CAR } ; SWAP ; PAIR ; PAIR ; DIP { DROP } ; NIL operation ; PAIR ; DIP { DROP 2 } } ; DIP { DROP } } { DIG 1 ; DUP ; DUG 2 ; DIG 7 ; DUP ; DUG 8 ; SWAP ; EXEC ; DIG 2 ; DUP ; DUG 3 ; DIG 2 ; DUP ; DUG 3 ; PAIR ; DUP ; CDR ; DIG 1 ; DUP ; DUG 2 ; CAR ; SOME ; SWAP ; CAR ; PAIR ; DIP { DROP } ; NIL operation ; PAIR ; DIP { DROP 2 } } ; DIP { DROP 2 } ; DIG 3 ; DUP ; DUG 4 ; DIG 1 ; DUP ; DUG 2 ; CDR ; SWAP ; CDR ; SWAP ; PAIR ; DIG 1 ; DUP ; DUG 2 ; CAR ; PAIR ; DIP { DROP 2 } } { DIG 2 ; DUP ; DUG 3 ; CAR ; CAR ; CDR ; IF { PUSH string \"PAUSED\" ; FAILWITH } { UNIT } ; DIG 3 ; DUP ; DUG 4 ; CDR ; DIG 2 ; DUP ; DUG 3 ; PAIR ; DUP ; CDR ; DIG 1 ; DUP ; DUG 2 ; CAR ; IF_LEFT { DUP ; IF_LEFT { DUP ; CAR ; DIG 1 ; DUP ; DUG 2 ; CDR ; PAIR ; DUP ; CDR ; MAP { DUP ; DIP { DROP } } ; DUP ; DIG 2 ; DUP ; DUG 3 ; CAR ; PAIR ; DIP { DROP 2 } ; DIG 3 ; DUP ; DUG 4 ; CAR ; CAR ; DIG 1 ; DUP ; DUG 2 ; PAIR ; DUP ; CAR ; DUP ; CDR ; MAP { PUSH nat 0 ; DIG 1 ; DUP ; DUG 2 ; CDR ; COMPARE ; NEQ ; IF { DIG 19 ; DUP ; DUG 20 ; FAILWITH } { DIG 2 ; DUP ; DUG 3 ; CDR ; DIG 1 ; DUP ; DUG 2 ; CAR ; PAIR ; DIG 17 ; DUP ; DUG 18 ; SWAP ; EXEC ; DIG 1 ; DUP ; DUG 2 ; DIG 1 ; DUP ; DUG 2 ; PAIR ; DUP ; CDR ; CDR ; DIG 1 ; DUP ; DUG 2 ; CDR ; CAR ; PAIR ; DIG 1 ; DUP ; DUG 2 ; CAR ; PAIR ; DUP ; CAR ; DIG 1 ; DUP ; DUG 2 ; CDR ; PAIR ; DIP { DROP 3 } } ; DIP { DROP } } ; DIG 1 ; DUP ; DUG 2 ; CAR ; PUSH mutez 0 ; DIG 2 ; DUP ; DUG 3 ; TRANSFER_TOKENS ; DIP { DROP 3 } ; DIG 4 ; DUP ; DUG 5 ; NIL operation ; DIG 2 ; DUP ; DUG 3 ; CONS ; PAIR ; DIP { DROP 3 } } { DUP ; PUSH mutez 0 ; SELF ; ADDRESS ; TRANSFER_TOKENS ; DIG 3 ; DUP ; DUG 4 ; NIL operation ; DIG 2 ; DUP ; DUG 3 ; CONS ; PAIR ; DIP { DROP 2 } } ; DIP { DROP } } { DUP ; IF_LEFT { DUP ; MAP { DUP ; CDR ; MAP { DUP ; CDR ; CAR ; DIG 1 ; DUP ; DUG 2 ; CAR ; DIG 2 ; DUP ; DUG 3 ; CDR ; CDR ; PAIR ; PAIR ; DIP { DROP } } ; DIG 1 ; DUP ; DUG 2 ; CAR ; PAIR ; DIP { DROP } } ; DUP ; MAP { DUP ; CDR ; MAP { PUSH nat 0 ; DIG 1 ; DUP ; DUG 2 ; CDR ; COMPARE ; NEQ ; IF { DIG 18 ; DUP ; DUG 19 ; FAILWITH } { DUP ; CDR ; DIG 1 ; DUP ; DUG 2 ; CAR ; CDR ; SOME ; DIG 2 ; DUP ; DUG 3 ; CAR ; CAR ; PAIR ; PAIR } ; DIP { DROP } } ; DUP ; DIG 2 ; DUP ; DUG 3 ; CAR ; SOME ; PAIR ; DIP { DROP 2 } } ; SENDER ; DUP ; LAMBDA (pair address (pair address (big_map (pair address address) unit))) unit { DUP ; CAR ; SWAP ; CDR ; DUP ; CAR ; DIG 2 ; DUP ; DUG 3 ; DIG 1 ; DUP ; DUG 2 ; COMPARE ; EQ ; IF { UNIT } { DIG 1 ; DUP ; DUG 2 ; CDR ; DIG 3 ; DUP ; DUG 4 ; DIG 2 ; DUP ; DUG 3 ; PAIR ; MEM ; IF { UNIT } { PUSH string \"FA2_NOT_OPERATOR\" ; FAILWITH } } ; DIP { DROP 3 } } ; SWAP ; APPLY ; DIP { DROP } ; DIG 5 ; DUP ; DUG 6 ; CAR ; CAR ; DIG 6 ; DUP ; DUG 7 ; CAR ; CDR ; PAIR ; DIG 1 ; DUP ; DUG 2 ; DIG 3 ; DUP ; DUG 4 ; PAIR ; PAIR ; DUP ; CDR ; CDR ; DIG 1 ; DUP ; DUG 2 ; CAR ; CAR ; ITER { SWAP ; PAIR ; DUP ; CDR ; DUP ; CAR ; IF_NONE { UNIT } { DIG 3 ; DUP ; DUG 4 ; CDR ; CAR ; DIG 1 ; DUP ; DUG 2 ; PAIR ; DIG 4 ; DUP ; DUG 5 ; CAR ; CDR ; SWAP ; EXEC ; DIP { DROP } } ; DIG 2 ; DUP ; DUG 3 ; CAR ; DIG 2 ; DUP ; DUG 3 ; CDR ; ITER { SWAP ; PAIR ; DUP ; CAR ; DIG 1 ; DUP ; DUG 2 ; CDR ; PUSH nat 0 ; DIG 1 ; DUP ; DUG 2 ; CDR ; COMPARE ; NEQ ; IF { DIG 25 ; DUP ; DUG 26 ; FAILWITH } { DIG 4 ; DUP ; DUG 5 ; CAR ; IF_NONE { DIG 1 ; DUP ; DUG 2 } { DIG 2 ; DUP ; DUG 3 ; DIG 2 ; DUP ; DUG 3 ; CAR ; CAR ; DIG 2 ; DUP ; DUG 3 ; PAIR ; PAIR ; DIG 22 ; DUP ; DUG 23 ; SWAP ; EXEC ; DIP { DROP } } ; DIG 1 ; DUP ; DUG 2 ; CAR ; CDR ; IF_NONE { DUP } { DIG 1 ; DUP ; DUG 2 ; DIG 3 ; DUP ; DUG 4 ; CAR ; CAR ; DIG 2 ; DUP ; DUG 3 ; PAIR ; PAIR ; DIG 24 ; DUP ; DUG 25 ; SWAP ; EXEC ; DIP { DROP } } ; DIP { DROP } } ; DIP { DROP 3 } } ; DIP { DROP 3 } } ; DIP { DROP } ; DIG 6 ; DUP ; DUG 7 ; DIG 1 ; DUP ; DUG 2 ; DIP { DUP ; CDR ; SWAP ; CAR ; CDR } ; PAIR ; PAIR ; NIL operation ; PAIR ; DIP { DROP 5 } } { DUP ; MAP { DUP ; IF_LEFT { DUP ; LEFT (pair (address %owner) (address %operator)) ; DIP { DROP } } { DUP ; RIGHT (pair (address %owner) (address %operator)) ; DIP { DROP } } ; DUP ; IF_LEFT { DUP ; DIG 17 ; DUP ; DUG 18 ; SWAP ; EXEC ; LEFT (pair (address %operator) (address %owner)) ; DIP { DROP } } { DUP ; DIG 17 ; DUP ; DUG 18 ; SWAP ; EXEC ; RIGHT (pair (address %operator) (address %owner)) ; DIP { DROP } } ; DIP { DROP 2 } } ; SENDER ; DIG 4 ; DUP ; DUG 5 ; CAR ; CDR ; DIG 2 ; DUP ; DUG 3 ; ITER { SWAP ; PAIR ; DUP ; CDR ; DIG 2 ; DUP ; DUG 3 ; DIG 1 ; DUP ; DUG 2 ; PAIR ; DUP ; CDR ; DIG 1 ; DUP ; DUG 2 ; CAR ; IF_LEFT { DUP ; DIP { DROP } } { DUP ; DIP { DROP } } ; CDR ; COMPARE ; EQ ; IF { UNIT } { PUSH string \"FA2_NOT_OWNER\" ; FAILWITH } ; DIP { DROP } ; DIG 2 ; DUP ; DUG 3 ; CAR ; DIG 2 ; DUP ; DUG 3 ; PAIR ; DUP ; CDR ; DIG 1 ; DUP ; DUG 2 ; CAR ; IF_LEFT { DIG 1 ; DUP ; DUG 2 ; UNIT ; SOME ; DIG 2 ; DUP ; DUG 3 ; CAR ; DIG 3 ; DUP ; DUG 4 ; CDR ; PAIR ; UPDATE ; DIP { DROP } } { DIG 1 ; DUP ; DUG 2 ; DIG 1 ; DUP ; DUG 2 ; CAR ; DIG 2 ; DUP ; DUG 3 ; CDR ; PAIR ; NONE unit ; SWAP ; UPDATE ; DIP { DROP } } ; DIP { DROP 5 } } ; DIG 5 ; DUP ; DUG 6 ; DIG 1 ; DUP ; DUG 2 ; DIP { DUP ; CDR ; SWAP ; CAR ; CAR } ; SWAP ; PAIR ; PAIR ; NIL operation ; PAIR ; DIP { DROP 4 } } ; DIP { DROP } } ; DIP { DROP 2 } ; DIG 4 ; DUP ; DUG 5 ; DIG 1 ; DUP ; DUG 2 ; CDR ; SWAP ; CAR ; PAIR ; DIG 1 ; DUP ; DUG 2 ; CAR ; PAIR ; DIP { DROP 3 } } ; DIP { DROP } } { DIG 1 ; DUP ; DUG 2 ; CAR ; DIG 3 ; DUP ; DUG 4 ; SWAP ; EXEC ; DIG 2 ; DUP ; DUG 3 ; CDR ; DIG 2 ; DUP ; DUG 3 ; PAIR ; DUP ; CDR ; DIG 1 ; DUP ; DUG 2 ; CAR ; IF_LEFT { DIG 1 ; DUP ; DUG 2 ; DIG 1 ; DUP ; DUG 2 ; PAIR ; DUP ; CAR ; DIG 1 ; DUP ; DUG 2 ; CDR ; DUP ; CAR ; CAR ; DIG 2 ; DUP ; DUG 3 ; PAIR ; DUP ; CDR ; DIG 1 ; DUP ; DUG 2 ; CAR ; ITER { SWAP ; PAIR ; DUP ; CDR ; DIG 1 ; DUP ; DUG 2 ; CAR ; DIG 1 ; DUP ; DUG 2 ; CAR ; DIG 2 ; DUP ; DUG 3 ; CDR ; PAIR ; PAIR ; DIG 15 ; DUP ; DUG 16 ; SWAP ; EXEC ; DIP { DROP 2 } } ; DIP { DROP } ; DIG 2 ; DUP ; DUG 3 ; DIG 12 ; DUP ; DUG 13 ; SWAP ; EXEC ; DUP ; DIG 3 ; DUP ; DUG 4 ; CDR ; CDR ; SUB ; ISNAT ; DUP ; IF_NONE { DIG 18 ; DUP ; DUG 19 ; FAILWITH } { DUP ; DIP { DROP } } ; DIG 4 ; DUP ; DUG 5 ; DIG 4 ; DUP ; DUG 5 ; DIP { DUP ; CDR ; SWAP ; CAR ; CDR } ; PAIR ; PAIR ; DIG 1 ; DUP ; DUG 2 ; DIP { DUP ; CAR ; SWAP ; CDR ; CAR } ; SWAP ; PAIR ; SWAP ; PAIR ; NIL operation ; PAIR ; DIP { DROP 8 } } { DIG 1 ; DUP ; DUG 2 ; DIG 1 ; DUP ; DUG 2 ; PAIR ; DUP ; CAR ; DIG 1 ; DUP ; DUG 2 ; CDR ; DUP ; CAR ; CAR ; DIG 2 ; DUP ; DUG 3 ; PAIR ; DUP ; CDR ; DIG 1 ; DUP ; DUG 2 ; CAR ; ITER { SWAP ; PAIR ; DUP ; CDR ; DIG 1 ; DUP ; DUG 2 ; CAR ; DIG 1 ; DUP ; DUG 2 ; CAR ; DIG 2 ; DUP ; DUG 3 ; CDR ; PAIR ; PAIR ; DIG 16 ; DUP ; DUG 17 ; SWAP ; EXEC ; DIP { DROP 2 } } ; DIP { DROP } ; DIG 2 ; DUP ; DUG 3 ; DIG 12 ; DUP ; DUG 13 ; SWAP ; EXEC ; DIG 2 ; DUP ; DUG 3 ; DIG 2 ; DUP ; DUG 3 ; DIP { DUP ; CDR ; SWAP ; CAR ; CDR } ; PAIR ; PAIR ; DIG 1 ; DUP ; DUG 2 ; DIG 4 ; DUP ; DUG 5 ; CDR ; CDR ; ADD ; DIP { DUP ; CAR ; SWAP ; CDR ; CAR } ; SWAP ; PAIR ; SWAP ; PAIR ; DUP ; NIL operation ; PAIR ; DIP { DROP 7 } } ; DIP { DROP 2 } ; DIG 3 ; DUP ; DUG 4 ; DIG 1 ; DUP ; DUG 2 ; CDR ; SWAP ; CAR ; PAIR ; DIG 1 ; DUP ; DUG 2 ; CAR ; PAIR ; DIP { DROP 3 } } ; DIP { DROP 10 } } ; `;\n            const storage = `( Pair ( Pair ( Pair \"${administrator}\" ${pause ? 'True' : 'False'} ) None ) ( Pair ( Pair { } { } ) ( Pair { Elt ${tokenid} ( Pair ${tokenid} ( Pair \"${symbol}\" ( Pair \"${name}\" ( Pair ${scale} { } ) ) ) ) } ${supply} ) ) )`;\n            const nodeResult = yield TezosNodeWriter_1.TezosNodeWriter.sendContractOriginationOperation(server, signer, keystore, 0, undefined, fee, freight, gas, contract, storage, TezosTypes.TezosParameterFormat.Michelson);\n            return TezosContractUtils_1.TezosContractUtils.clearRPCOperationGroupHash(nodeResult['operationGroupID']);\n        });\n    }\n    SingleAssetTokenHelper.deployContract = deployContract;\n    function getSimpleStorage(server, address) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const storageResult = yield TezosNodeReader_1.TezosNodeReader.getContractStorage(server, address);\n            return {\n                administrator: jsonpath_plus_1.JSONPath({ path: '$.args[0].args[0].args[0].string', json: storageResult })[0],\n                paused: (jsonpath_plus_1.JSONPath({ path: '$.args[0].args[0].args[1].prim', json: storageResult })[0]).toString().toLowerCase().startsWith('t'),\n                pendingAdmin: jsonpath_plus_1.JSONPath({ path: '$.args[0].args[1].prim', json: storageResult })[0],\n                balanceMap: Number(jsonpath_plus_1.JSONPath({ path: '$.args[1].args[0].args[0].int', json: storageResult })[0]),\n                operatorMap: Number(jsonpath_plus_1.JSONPath({ path: '$.args[1].args[0].args[1].int', json: storageResult })[0]),\n                metadataMap: Number(jsonpath_plus_1.JSONPath({ path: '$.args[1].args[1].args[0].int', json: storageResult })[0]),\n                supply: Number(jsonpath_plus_1.JSONPath({ path: '$.args[1].args[1].args[1].int', json: storageResult })[0])\n            };\n        });\n    }\n    SingleAssetTokenHelper.getSimpleStorage = getSimpleStorage;\n    function getTokenDefinition(server, mapid, token = 0) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const packedKey = TezosMessageUtil_1.TezosMessageUtils.encodeBigMapKey(Buffer.from(TezosMessageUtil_1.TezosMessageUtils.writePackedData(token, 'nat'), 'hex'));\n            const mapResult = yield TezosNodeReader_1.TezosNodeReader.getValueForBigMapKey(server, mapid, packedKey);\n            if (mapResult === undefined) {\n                throw new Error(`Map ${mapid} does not contain a record for token ${token}`);\n            }\n            return {\n                tokenid: Number(jsonpath_plus_1.JSONPath({ path: '$.args[0].int', json: mapResult })[0]),\n                symbol: jsonpath_plus_1.JSONPath({ path: '$.args[1].args[0].string', json: mapResult })[0],\n                name: jsonpath_plus_1.JSONPath({ path: '$.args[1].args[1].args[0].string', json: mapResult })[0],\n                scale: Number(jsonpath_plus_1.JSONPath({ path: '$.args[1].args[1].args[1].args[0].int', json: mapResult })[0])\n            };\n        });\n    }\n    SingleAssetTokenHelper.getTokenDefinition = getTokenDefinition;\n    function activate(server, address, signer, keystore, fee, gas = 800000, freight = 20000) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const entryPoint = 'pause';\n            const parameters = 'False';\n            const nodeResult = yield TezosNodeWriter_1.TezosNodeWriter.sendContractInvocationOperation(server, signer, keystore, address, 0, fee, freight, gas, entryPoint, parameters, TezosTypes.TezosParameterFormat.Michelson);\n            return TezosContractUtils_1.TezosContractUtils.clearRPCOperationGroupHash(nodeResult.operationGroupID);\n        });\n    }\n    SingleAssetTokenHelper.activate = activate;\n    function deactivate(server, address, signer, keystore, fee, gas = 800000, freight = 20000) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const entryPoint = 'pause';\n            const parameters = 'True';\n            const nodeResult = yield TezosNodeWriter_1.TezosNodeWriter.sendContractInvocationOperation(server, signer, keystore, address, 0, fee, freight, gas, entryPoint, parameters, TezosTypes.TezosParameterFormat.Michelson);\n            return TezosContractUtils_1.TezosContractUtils.clearRPCOperationGroupHash(nodeResult.operationGroupID);\n        });\n    }\n    SingleAssetTokenHelper.deactivate = deactivate;\n    function mint(server, address, signer, keystore, fee, issue, gas = 800000, freight = 20000) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const entryPoint = 'mint_tokens';\n            const parameters = `{ ${issue.map(i => '( Pair ' + i.balance + ' \"' + i.address + '\" )').join(' ; ')} }`;\n            const nodeResult = yield TezosNodeWriter_1.TezosNodeWriter.sendContractInvocationOperation(server, signer, keystore, address, 0, fee, freight, gas, entryPoint, parameters, TezosTypes.TezosParameterFormat.Michelson);\n            return TezosContractUtils_1.TezosContractUtils.clearRPCOperationGroupHash(nodeResult.operationGroupID);\n        });\n    }\n    SingleAssetTokenHelper.mint = mint;\n    function transfer(server, address, signer, keystore, fee, source, transfers, gas = 800000, freight = 20000) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const entryPoint = 'transfer';\n            const parameters = `{ Pair \"${source}\" { ${transfers.map(t => '( Pair \"' + t.address + '\" ( Pair ' + t.tokenid + ' ' + t.balance + ' ) )').join(' ; ')} } }`;\n            const nodeResult = yield TezosNodeWriter_1.TezosNodeWriter.sendContractInvocationOperation(server, signer, keystore, address, 0, fee, freight, gas, entryPoint, parameters, TezosTypes.TezosParameterFormat.Michelson);\n            return TezosContractUtils_1.TezosContractUtils.clearRPCOperationGroupHash(nodeResult.operationGroupID);\n        });\n    }\n    SingleAssetTokenHelper.transfer = transfer;\n    function getAccountBalance(server, mapid, account) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const packedKey = TezosMessageUtil_1.TezosMessageUtils.encodeBigMapKey(Buffer.from(TezosMessageUtil_1.TezosMessageUtils.writePackedData(account, 'address'), 'hex'));\n            const mapResult = yield TezosNodeReader_1.TezosNodeReader.getValueForBigMapKey(server, mapid, packedKey);\n            if (mapResult === undefined) {\n                throw new Error(`Map ${mapid} does not contain a record for ${account}`);\n            }\n            const jsonresult = jsonpath_plus_1.JSONPath({ path: '$.int', json: mapResult });\n            return Number(jsonresult[0]);\n        });\n    }\n    SingleAssetTokenHelper.getAccountBalance = getAccountBalance;\n})(SingleAssetTokenHelper = exports.SingleAssetTokenHelper || (exports.SingleAssetTokenHelper = {}));\n//# sourceMappingURL=SingleAssetTokenHelper.js.map"]},"metadata":{},"sourceType":"script"}