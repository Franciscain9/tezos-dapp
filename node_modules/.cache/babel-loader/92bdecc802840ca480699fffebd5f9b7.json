{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst bip39 = __importStar(require(\"bip39\"));\n\nconst conseiljs_1 = require(\"conseiljs\");\n\nconst conseiljs_2 = require(\"conseiljs\");\n\nconst CryptoUtils_1 = require(\"./utils/CryptoUtils\");\n\nvar KeyStoreUtils;\n\n(function (KeyStoreUtils) {\n  function generateMnemonic(strength = 256) {\n    return bip39.generateMnemonic(strength);\n  }\n\n  KeyStoreUtils.generateMnemonic = generateMnemonic;\n\n  function generateIdentity(strength = 256, password = '', mnemonic) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return restoreIdentityFromMnemonic(mnemonic || bip39.generateMnemonic(strength), password);\n    });\n  }\n\n  KeyStoreUtils.generateIdentity = generateIdentity;\n\n  function restoreIdentityFromSecretKey(secretKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const secretKeyBytes = conseiljs_2.TezosMessageUtils.writeKeyWithHint(secretKey, 'edsk');\n      const keys = yield recoverKeys(secretKeyBytes);\n      const publicKey = conseiljs_2.TezosMessageUtils.readKeyWithHint(keys.publicKey, 'edpk');\n      const publicKeyHash = conseiljs_2.TezosMessageUtils.computeKeyHash(keys.publicKey, 'tz1');\n      return {\n        publicKey,\n        secretKey,\n        publicKeyHash,\n        curve: conseiljs_1.KeyStoreCurve.ED25519,\n        storeType: conseiljs_1.KeyStoreType.Mnemonic\n      };\n    });\n  }\n\n  KeyStoreUtils.restoreIdentityFromSecretKey = restoreIdentityFromSecretKey;\n\n  function restoreIdentityFromMnemonic(mnemonic, password = '', pkh, derivationPath, validate = true) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (validate) {\n        if (![12, 15, 18, 21, 24].includes(mnemonic.split(' ').length)) {\n          throw new Error('Invalid mnemonic length.');\n        }\n\n        if (!bip39.validateMnemonic(mnemonic)) {\n          throw new Error('The given mnemonic could not be validated.');\n        }\n      }\n\n      const seed = (yield bip39.mnemonicToSeed(mnemonic, password)).slice(0, 32);\n      const keys = yield generateKeys(seed);\n      const secretKey = conseiljs_2.TezosMessageUtils.readKeyWithHint(keys.secretKey, 'edsk');\n      const publicKey = conseiljs_2.TezosMessageUtils.readKeyWithHint(keys.publicKey, 'edpk');\n      const publicKeyHash = conseiljs_2.TezosMessageUtils.computeKeyHash(keys.publicKey, 'tz1');\n\n      if (!!pkh && publicKeyHash !== pkh) {\n        throw new Error('The given mnemonic and passphrase do not correspond to the supplied public key hash');\n      }\n\n      return {\n        publicKey,\n        secretKey,\n        publicKeyHash,\n        curve: conseiljs_1.KeyStoreCurve.ED25519,\n        storeType: conseiljs_1.KeyStoreType.Mnemonic,\n        seed: mnemonic,\n        derivationPath\n      };\n    });\n  }\n\n  KeyStoreUtils.restoreIdentityFromMnemonic = restoreIdentityFromMnemonic;\n\n  function restoreIdentityFromFundraiser(mnemonic, email, password, pkh) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield restoreIdentityFromMnemonic(mnemonic, email + password, pkh);\n    });\n  }\n\n  KeyStoreUtils.restoreIdentityFromFundraiser = restoreIdentityFromFundraiser;\n\n  function generateKeys(seed) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const keys = yield CryptoUtils_1.CryptoUtils.generateKeys(seed);\n      return {\n        publicKey: keys.publicKey,\n        secretKey: keys.secretKey\n      };\n    });\n  }\n\n  KeyStoreUtils.generateKeys = generateKeys;\n\n  function recoverKeys(secretKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const keys = yield CryptoUtils_1.CryptoUtils.recoverPublicKey(secretKey);\n      return {\n        publicKey: keys.publicKey,\n        secretKey: keys.secretKey\n      };\n    });\n  }\n\n  KeyStoreUtils.recoverKeys = recoverKeys;\n\n  function decryptMessage(message, passphrase, salt) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return CryptoUtils_1.CryptoUtils.decryptMessage(message, passphrase, salt);\n    });\n  }\n\n  KeyStoreUtils.decryptMessage = decryptMessage;\n\n  function encryptMessage(message, passphrase, salt) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return CryptoUtils_1.CryptoUtils.encryptMessage(message, passphrase, salt);\n    });\n  }\n\n  KeyStoreUtils.encryptMessage = encryptMessage;\n\n  function checkTextSignature(signature, message, publicKey, prehash = false) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let messageBytes;\n\n      if (prehash) {\n        messageBytes = conseiljs_2.TezosMessageUtils.simpleHash(Buffer.from(message, 'utf8'), 32);\n      } else {\n        messageBytes = Buffer.from(message, 'utf8');\n      }\n\n      const sig = conseiljs_2.TezosMessageUtils.writeSignatureWithHint(signature, 'edsig');\n      const pk = conseiljs_2.TezosMessageUtils.writeKeyWithHint(publicKey, 'edpk');\n      return yield CryptoUtils_1.CryptoUtils.checkSignature(sig, messageBytes, pk);\n    });\n  }\n\n  KeyStoreUtils.checkTextSignature = checkTextSignature;\n})(KeyStoreUtils = exports.KeyStoreUtils || (exports.KeyStoreUtils = {}));","map":{"version":3,"sources":["../src/KeyStoreUtils.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,MAAA,KAAA,GAAA,YAAA,CAAA,OAAA,CAAA,OAAA,CAAA,CAAA;;AAEA,MAAA,WAAA,GAAA,OAAA,CAAA,WAAA,CAAA;;AACA,MAAA,WAAA,GAAA,OAAA,CAAA,WAAA,CAAA;;AAEA,MAAA,aAAA,GAAA,OAAA,CAAA,qBAAA,CAAA;;AAKA,IAAiB,aAAjB;;AAAA,CAAA,UAAiB,aAAjB,EAA8B;AAK1B,WAAgB,gBAAhB,CAAiC,QAAA,GAAmB,GAApD,EAAuD;AACnD,WAAO,KAAK,CAAC,gBAAN,CAAuB,QAAvB,CAAP;AACH;;AAFe,EAAA,aAAA,CAAA,gBAAA,GAAgB,gBAAhB;;AAUhB,WAAsB,gBAAtB,CAAuC,QAAA,GAAmB,GAA1D,EAA+D,QAAA,GAAmB,EAAlF,EAAsF,QAAtF,EAAuG;;AACnG,aAAO,2BAA2B,CAAE,QAAQ,IAAI,KAAK,CAAC,gBAAN,CAAuB,QAAvB,CAAd,EAAiD,QAAjD,CAAlC;AACH,K;AAAA;;AAFqB,EAAA,aAAA,CAAA,gBAAA,GAAgB,gBAAhB;;AAStB,WAAsB,4BAAtB,CAAmD,SAAnD,EAAoE;;AAChE,YAAM,cAAc,GAAG,WAAA,CAAA,iBAAA,CAAkB,gBAAlB,CAAmC,SAAnC,EAA8C,MAA9C,CAAvB;AACA,YAAM,IAAI,GAAG,MAAM,WAAW,CAAC,cAAD,CAA9B;AAEA,YAAM,SAAS,GAAG,WAAA,CAAA,iBAAA,CAAkB,eAAlB,CAAkC,IAAI,CAAC,SAAvC,EAAkD,MAAlD,CAAlB;AACA,YAAM,aAAa,GAAG,WAAA,CAAA,iBAAA,CAAkB,cAAlB,CAAiC,IAAI,CAAC,SAAtC,EAAiD,KAAjD,CAAtB;AAEA,aAAO;AAAE,QAAA,SAAF;AAAa,QAAA,SAAb;AAAwB,QAAA,aAAxB;AAAuC,QAAA,KAAK,EAAE,WAAA,CAAA,aAAA,CAAc,OAA5D;AAAqE,QAAA,SAAS,EAAE,WAAA,CAAA,YAAA,CAAa;AAA7F,OAAP;AACH,K;AAAA;;AARqB,EAAA,aAAA,CAAA,4BAAA,GAA4B,4BAA5B;;AAmBtB,WAAsB,2BAAtB,CAAkD,QAAlD,EAAoE,QAAA,GAAmB,EAAvF,EAA2F,GAA3F,EAAyG,cAAzG,EAAkI,QAAA,GAAoB,IAAtJ,EAA0J;;AACtJ,UAAI,QAAJ,EAAc;AACV,YAAI,CAAC,CAAC,EAAD,EAAK,EAAL,EAAS,EAAT,EAAa,EAAb,EAAiB,EAAjB,EAAqB,QAArB,CAA8B,QAAQ,CAAC,KAAT,CAAe,GAAf,EAAoB,MAAlD,CAAL,EAAgE;AAAE,gBAAM,IAAI,KAAJ,CAAU,0BAAV,CAAN;AAA8C;;AAChH,YAAI,CAAC,KAAK,CAAC,gBAAN,CAAuB,QAAvB,CAAL,EAAuC;AAAE,gBAAM,IAAI,KAAJ,CAAU,4CAAV,CAAN;AAAgE;AAC5G;;AAED,YAAM,IAAI,GAAG,CAAC,MAAM,KAAK,CAAC,cAAN,CAAqB,QAArB,EAA+B,QAA/B,CAAP,EAAiD,KAAjD,CAAuD,CAAvD,EAA0D,EAA1D,CAAb;AACA,YAAM,IAAI,GAAG,MAAM,YAAY,CAAC,IAAD,CAA/B;AACA,YAAM,SAAS,GAAG,WAAA,CAAA,iBAAA,CAAkB,eAAlB,CAAkC,IAAI,CAAC,SAAvC,EAAkD,MAAlD,CAAlB;AACA,YAAM,SAAS,GAAG,WAAA,CAAA,iBAAA,CAAkB,eAAlB,CAAkC,IAAI,CAAC,SAAvC,EAAkD,MAAlD,CAAlB;AACA,YAAM,aAAa,GAAG,WAAA,CAAA,iBAAA,CAAkB,cAAlB,CAAiC,IAAI,CAAC,SAAtC,EAAiD,KAAjD,CAAtB;;AAEA,UAAI,CAAC,CAAC,GAAF,IAAS,aAAa,KAAK,GAA/B,EAAoC;AAAE,cAAM,IAAI,KAAJ,CAAU,qFAAV,CAAN;AAAyG;;AAE/I,aAAO;AAAC,QAAA,SAAD;AAAY,QAAA,SAAZ;AAAuB,QAAA,aAAvB;AAAsC,QAAA,KAAK,EAAE,WAAA,CAAA,aAAA,CAAc,OAA3D;AAAoE,QAAA,SAAS,EAAE,WAAA,CAAA,YAAA,CAAa,QAA5F;AAAsG,QAAA,IAAI,EAAE,QAA5G;AAAsH,QAAA;AAAtH,OAAP;AACH,K;AAAA;;AAfqB,EAAA,aAAA,CAAA,2BAAA,GAA2B,2BAA3B;;AA4BtB,WAAsB,6BAAtB,CAAoD,QAApD,EAAsE,KAAtE,EAAqF,QAArF,EAAuG,GAAvG,EAAkH;;AAC9G,aAAO,MAAM,2BAA2B,CAAC,QAAD,EAAW,KAAK,GAAG,QAAnB,EAA6B,GAA7B,CAAxC;AACH,K;AAAA;;AAFqB,EAAA,aAAA,CAAA,6BAAA,GAA6B,6BAA7B;;AAQtB,WAAsB,YAAtB,CAAmC,IAAnC,EAA+C;;AAC3C,YAAM,IAAI,GAAG,MAAM,aAAA,CAAA,WAAA,CAAY,YAAZ,CAAyB,IAAzB,CAAnB;AACA,aAAO;AAAE,QAAA,SAAS,EAAE,IAAI,CAAC,SAAlB;AAA6B,QAAA,SAAS,EAAE,IAAI,CAAC;AAA7C,OAAP;AACH,K;AAAA;;AAHqB,EAAA,aAAA,CAAA,YAAA,GAAY,YAAZ;;AAKtB,WAAsB,WAAtB,CAAkC,SAAlC,EAAmD;;AAC/C,YAAM,IAAI,GAAG,MAAM,aAAA,CAAA,WAAA,CAAY,gBAAZ,CAA6B,SAA7B,CAAnB;AACA,aAAO;AAAE,QAAA,SAAS,EAAE,IAAI,CAAC,SAAlB;AAA6B,QAAA,SAAS,EAAE,IAAI,CAAC;AAA7C,OAAP;AACH,K;AAAA;;AAHqB,EAAA,aAAA,CAAA,WAAA,GAAW,WAAX;;AAWtB,WAAsB,cAAtB,CAAqC,OAArC,EAAsD,UAAtD,EAA0E,IAA1E,EAAsF;;AAClF,aAAO,aAAA,CAAA,WAAA,CAAY,cAAZ,CAA2B,OAA3B,EAAoC,UAApC,EAAgD,IAAhD,CAAP;AACH,K;AAAA;;AAFqB,EAAA,aAAA,CAAA,cAAA,GAAc,cAAd;;AAUtB,WAAsB,cAAtB,CAAqC,OAArC,EAAsD,UAAtD,EAA0E,IAA1E,EAAsF;;AAClF,aAAO,aAAA,CAAA,WAAA,CAAY,cAAZ,CAA2B,OAA3B,EAAoC,UAApC,EAAgD,IAAhD,CAAP;AACH,K;AAAA;;AAFqB,EAAA,aAAA,CAAA,cAAA,GAAc,cAAd;;AAatB,WAAsB,kBAAtB,CAAyC,SAAzC,EAA4D,OAA5D,EAA6E,SAA7E,EAAgG,OAAO,GAAG,KAA1G,EAA+G;;AAC3G,UAAI,YAAJ;;AACA,UAAI,OAAJ,EAAa;AACT,QAAA,YAAY,GAAG,WAAA,CAAA,iBAAA,CAAkB,UAAlB,CAA6B,MAAM,CAAC,IAAP,CAAY,OAAZ,EAAqB,MAArB,CAA7B,EAA2D,EAA3D,CAAf;AACH,OAFD,MAEO;AACH,QAAA,YAAY,GAAG,MAAM,CAAC,IAAP,CAAY,OAAZ,EAAqB,MAArB,CAAf;AACH;;AAED,YAAM,GAAG,GAAG,WAAA,CAAA,iBAAA,CAAkB,sBAAlB,CAAyC,SAAzC,EAAoD,OAApD,CAAZ;AACA,YAAM,EAAE,GAAG,WAAA,CAAA,iBAAA,CAAkB,gBAAlB,CAAmC,SAAnC,EAA8C,MAA9C,CAAX;AAEA,aAAO,MAAM,aAAA,CAAA,WAAA,CAAY,cAAZ,CAA2B,GAA3B,EAAgC,YAAhC,EAA8C,EAA9C,CAAb;AACH,K;AAAA;;AAZqB,EAAA,aAAA,CAAA,kBAAA,GAAkB,kBAAlB;AAazB,CAnID,EAAiB,aAAa,GAAb,OAAA,CAAA,aAAA,KAAA,OAAA,CAAA,aAAA,GAAa,EAAb,CAAjB","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst bip39 = __importStar(require(\"bip39\"));\nconst conseiljs_1 = require(\"conseiljs\");\nconst conseiljs_2 = require(\"conseiljs\");\nconst CryptoUtils_1 = require(\"./utils/CryptoUtils\");\nvar KeyStoreUtils;\n(function (KeyStoreUtils) {\n    function generateMnemonic(strength = 256) {\n        return bip39.generateMnemonic(strength);\n    }\n    KeyStoreUtils.generateMnemonic = generateMnemonic;\n    function generateIdentity(strength = 256, password = '', mnemonic) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return restoreIdentityFromMnemonic((mnemonic || bip39.generateMnemonic(strength)), password);\n        });\n    }\n    KeyStoreUtils.generateIdentity = generateIdentity;\n    function restoreIdentityFromSecretKey(secretKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const secretKeyBytes = conseiljs_2.TezosMessageUtils.writeKeyWithHint(secretKey, 'edsk');\n            const keys = yield recoverKeys(secretKeyBytes);\n            const publicKey = conseiljs_2.TezosMessageUtils.readKeyWithHint(keys.publicKey, 'edpk');\n            const publicKeyHash = conseiljs_2.TezosMessageUtils.computeKeyHash(keys.publicKey, 'tz1');\n            return { publicKey, secretKey, publicKeyHash, curve: conseiljs_1.KeyStoreCurve.ED25519, storeType: conseiljs_1.KeyStoreType.Mnemonic };\n        });\n    }\n    KeyStoreUtils.restoreIdentityFromSecretKey = restoreIdentityFromSecretKey;\n    function restoreIdentityFromMnemonic(mnemonic, password = '', pkh, derivationPath, validate = true) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (validate) {\n                if (![12, 15, 18, 21, 24].includes(mnemonic.split(' ').length)) {\n                    throw new Error('Invalid mnemonic length.');\n                }\n                if (!bip39.validateMnemonic(mnemonic)) {\n                    throw new Error('The given mnemonic could not be validated.');\n                }\n            }\n            const seed = (yield bip39.mnemonicToSeed(mnemonic, password)).slice(0, 32);\n            const keys = yield generateKeys(seed);\n            const secretKey = conseiljs_2.TezosMessageUtils.readKeyWithHint(keys.secretKey, 'edsk');\n            const publicKey = conseiljs_2.TezosMessageUtils.readKeyWithHint(keys.publicKey, 'edpk');\n            const publicKeyHash = conseiljs_2.TezosMessageUtils.computeKeyHash(keys.publicKey, 'tz1');\n            if (!!pkh && publicKeyHash !== pkh) {\n                throw new Error('The given mnemonic and passphrase do not correspond to the supplied public key hash');\n            }\n            return { publicKey, secretKey, publicKeyHash, curve: conseiljs_1.KeyStoreCurve.ED25519, storeType: conseiljs_1.KeyStoreType.Mnemonic, seed: mnemonic, derivationPath };\n        });\n    }\n    KeyStoreUtils.restoreIdentityFromMnemonic = restoreIdentityFromMnemonic;\n    function restoreIdentityFromFundraiser(mnemonic, email, password, pkh) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield restoreIdentityFromMnemonic(mnemonic, email + password, pkh);\n        });\n    }\n    KeyStoreUtils.restoreIdentityFromFundraiser = restoreIdentityFromFundraiser;\n    function generateKeys(seed) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const keys = yield CryptoUtils_1.CryptoUtils.generateKeys(seed);\n            return { publicKey: keys.publicKey, secretKey: keys.secretKey };\n        });\n    }\n    KeyStoreUtils.generateKeys = generateKeys;\n    function recoverKeys(secretKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const keys = yield CryptoUtils_1.CryptoUtils.recoverPublicKey(secretKey);\n            return { publicKey: keys.publicKey, secretKey: keys.secretKey };\n        });\n    }\n    KeyStoreUtils.recoverKeys = recoverKeys;\n    function decryptMessage(message, passphrase, salt) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return CryptoUtils_1.CryptoUtils.decryptMessage(message, passphrase, salt);\n        });\n    }\n    KeyStoreUtils.decryptMessage = decryptMessage;\n    function encryptMessage(message, passphrase, salt) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return CryptoUtils_1.CryptoUtils.encryptMessage(message, passphrase, salt);\n        });\n    }\n    KeyStoreUtils.encryptMessage = encryptMessage;\n    function checkTextSignature(signature, message, publicKey, prehash = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let messageBytes;\n            if (prehash) {\n                messageBytes = conseiljs_2.TezosMessageUtils.simpleHash(Buffer.from(message, 'utf8'), 32);\n            }\n            else {\n                messageBytes = Buffer.from(message, 'utf8');\n            }\n            const sig = conseiljs_2.TezosMessageUtils.writeSignatureWithHint(signature, 'edsig');\n            const pk = conseiljs_2.TezosMessageUtils.writeKeyWithHint(publicKey, 'edpk');\n            return yield CryptoUtils_1.CryptoUtils.checkSignature(sig, messageBytes, pk);\n        });\n    }\n    KeyStoreUtils.checkTextSignature = checkTextSignature;\n})(KeyStoreUtils = exports.KeyStoreUtils || (exports.KeyStoreUtils = {}));\n//# sourceMappingURL=KeyStoreUtils.js.map"]},"metadata":{},"sourceType":"script"}