{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst wrapper = require('./WrapperWrapper');\n\nvar CryptoUtils;\n\n(function (CryptoUtils) {\n  function generateSaltForPwHash() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const s = yield wrapper.salt();\n      return s;\n    });\n  }\n\n  CryptoUtils.generateSaltForPwHash = generateSaltForPwHash;\n\n  function encryptMessage(message, passphrase, salt) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const keyBytes = yield wrapper.pwhash(passphrase, salt);\n      const n = yield wrapper.nonce();\n      const nonce = Buffer.from(n);\n      const s = yield wrapper.close(message, nonce, keyBytes);\n      const cipherText = Buffer.from(s);\n      return Buffer.concat([nonce, cipherText]);\n    });\n  }\n\n  CryptoUtils.encryptMessage = encryptMessage;\n\n  function decryptMessage(message, passphrase, salt) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const keyBytes = yield wrapper.pwhash(passphrase, salt);\n      const m = yield wrapper.open(message, keyBytes);\n      return Buffer.from(m);\n    });\n  }\n\n  CryptoUtils.decryptMessage = decryptMessage;\n\n  function generateKeys(seed) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const k = yield wrapper.keys(seed);\n      return {\n        secretKey: k.privateKey,\n        publicKey: k.publicKey\n      };\n    });\n  }\n\n  CryptoUtils.generateKeys = generateKeys;\n\n  function recoverPublicKey(secretKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const k = yield wrapper.publicKey(secretKey);\n      return {\n        secretKey: k.privateKey,\n        publicKey: k.publicKey\n      };\n    });\n  }\n\n  CryptoUtils.recoverPublicKey = recoverPublicKey;\n\n  function signDetached(payload, secretKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const b = yield wrapper.sign(payload, secretKey);\n      return Buffer.from(b);\n    });\n  }\n\n  CryptoUtils.signDetached = signDetached;\n\n  function checkSignature(signature, payload, publicKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield wrapper.checkSignature(signature, payload, publicKey);\n    });\n  }\n\n  CryptoUtils.checkSignature = checkSignature;\n})(CryptoUtils = exports.CryptoUtils || (exports.CryptoUtils = {}));","map":{"version":3,"sources":["../../src/utils/CryptoUtils.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,MAAM,OAAO,GAAG,OAAO,CAAC,kBAAD,CAAvB;;AAKA,IAAiB,WAAjB;;AAAA,CAAA,UAAiB,WAAjB,EAA4B;AAMxB,WAAsB,qBAAtB,GAA2C;;AACvC,YAAM,CAAC,GAAG,MAAM,OAAO,CAAC,IAAR,EAAhB;AACA,aAAO,CAAP;AACH,K;AAAA;;AAHqB,EAAA,WAAA,CAAA,qBAAA,GAAqB,qBAArB;;AAatB,WAAsB,cAAtB,CAAqC,OAArC,EAAsD,UAAtD,EAA0E,IAA1E,EAAsF;;AAClF,YAAM,QAAQ,GAAG,MAAM,OAAO,CAAC,MAAR,CAAe,UAAf,EAA2B,IAA3B,CAAvB;AACA,YAAM,CAAC,GAAG,MAAM,OAAO,CAAC,KAAR,EAAhB;AACA,YAAM,KAAK,GAAG,MAAM,CAAC,IAAP,CAAY,CAAZ,CAAd;AACA,YAAM,CAAC,GAAG,MAAM,OAAO,CAAC,KAAR,CAAc,OAAd,EAAuB,KAAvB,EAA8B,QAA9B,CAAhB;AACA,YAAM,UAAU,GAAG,MAAM,CAAC,IAAP,CAAY,CAAZ,CAAnB;AAEA,aAAO,MAAM,CAAC,MAAP,CAAc,CAAC,KAAD,EAAQ,UAAR,CAAd,CAAP;AACH,K;AAAA;;AARqB,EAAA,WAAA,CAAA,cAAA,GAAc,cAAd;;AAkBtB,WAAsB,cAAtB,CAAqC,OAArC,EAAsD,UAAtD,EAA0E,IAA1E,EAAsF;;AAClF,YAAM,QAAQ,GAAG,MAAM,OAAO,CAAC,MAAR,CAAe,UAAf,EAA2B,IAA3B,CAAvB;AACA,YAAM,CAAC,GAAG,MAAM,OAAO,CAAC,IAAR,CAAa,OAAb,EAAsB,QAAtB,CAAhB;AACA,aAAO,MAAM,CAAC,IAAP,CAAY,CAAZ,CAAP;AACH,K;AAAA;;AAJqB,EAAA,WAAA,CAAA,cAAA,GAAc,cAAd;;AAWtB,WAAsB,YAAtB,CAAmC,IAAnC,EAA+C;;AAC3C,YAAM,CAAC,GAAG,MAAM,OAAO,CAAC,IAAR,CAAa,IAAb,CAAhB;AAEA,aAAO;AAAE,QAAA,SAAS,EAAE,CAAC,CAAC,UAAf;AAA2B,QAAA,SAAS,EAAE,CAAC,CAAC;AAAxC,OAAP;AACH,K;AAAA;;AAJqB,EAAA,WAAA,CAAA,YAAA,GAAY,YAAZ;;AAWtB,WAAsB,gBAAtB,CAAuC,SAAvC,EAAwD;;AACpD,YAAM,CAAC,GAAG,MAAM,OAAO,CAAC,SAAR,CAAkB,SAAlB,CAAhB;AAEA,aAAO;AAAE,QAAA,SAAS,EAAE,CAAC,CAAC,UAAf;AAA2B,QAAA,SAAS,EAAE,CAAC,CAAC;AAAxC,OAAP;AACH,K;AAAA;;AAJqB,EAAA,WAAA,CAAA,gBAAA,GAAgB,gBAAhB;;AAYtB,WAAsB,YAAtB,CAAmC,OAAnC,EAAoD,SAApD,EAAqE;;AACjE,YAAM,CAAC,GAAG,MAAM,OAAO,CAAC,IAAR,CAAa,OAAb,EAAsB,SAAtB,CAAhB;AACA,aAAO,MAAM,CAAC,IAAP,CAAY,CAAZ,CAAP;AACH,K;AAAA;;AAHqB,EAAA,WAAA,CAAA,YAAA,GAAY,YAAZ;;AAKtB,WAAsB,cAAtB,CAAqC,SAArC,EAAwD,OAAxD,EAAyE,SAAzE,EAA0F;;AACtF,aAAO,MAAM,OAAO,CAAC,cAAR,CAAuB,SAAvB,EAAkC,OAAlC,EAA2C,SAA3C,CAAb;AACH,K;AAAA;;AAFqB,EAAA,WAAA,CAAA,cAAA,GAAc,cAAd;AAGzB,CA/ED,EAAiB,WAAW,GAAX,OAAA,CAAA,WAAA,KAAA,OAAA,CAAA,WAAA,GAAW,EAAX,CAAjB","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst wrapper = require('./WrapperWrapper');\nvar CryptoUtils;\n(function (CryptoUtils) {\n    function generateSaltForPwHash() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const s = yield wrapper.salt();\n            return s;\n        });\n    }\n    CryptoUtils.generateSaltForPwHash = generateSaltForPwHash;\n    function encryptMessage(message, passphrase, salt) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const keyBytes = yield wrapper.pwhash(passphrase, salt);\n            const n = yield wrapper.nonce();\n            const nonce = Buffer.from(n);\n            const s = yield wrapper.close(message, nonce, keyBytes);\n            const cipherText = Buffer.from(s);\n            return Buffer.concat([nonce, cipherText]);\n        });\n    }\n    CryptoUtils.encryptMessage = encryptMessage;\n    function decryptMessage(message, passphrase, salt) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const keyBytes = yield wrapper.pwhash(passphrase, salt);\n            const m = yield wrapper.open(message, keyBytes);\n            return Buffer.from(m);\n        });\n    }\n    CryptoUtils.decryptMessage = decryptMessage;\n    function generateKeys(seed) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const k = yield wrapper.keys(seed);\n            return { secretKey: k.privateKey, publicKey: k.publicKey };\n        });\n    }\n    CryptoUtils.generateKeys = generateKeys;\n    function recoverPublicKey(secretKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const k = yield wrapper.publicKey(secretKey);\n            return { secretKey: k.privateKey, publicKey: k.publicKey };\n        });\n    }\n    CryptoUtils.recoverPublicKey = recoverPublicKey;\n    function signDetached(payload, secretKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const b = yield wrapper.sign(payload, secretKey);\n            return Buffer.from(b);\n        });\n    }\n    CryptoUtils.signDetached = signDetached;\n    function checkSignature(signature, payload, publicKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield wrapper.checkSignature(signature, payload, publicKey);\n        });\n    }\n    CryptoUtils.checkSignature = checkSignature;\n})(CryptoUtils = exports.CryptoUtils || (exports.CryptoUtils = {}));\n//# sourceMappingURL=CryptoUtils.js.map"]},"metadata":{},"sourceType":"script"}