{"ast":null,"code":"import { RpcClient, OpKind } from '@taquito/rpc';\nexport { OpKind } from '@taquito/rpc';\nimport { InMemorySigner } from '@taquito/signer';\nimport { Schema, ParameterSchema } from '@taquito/michelson-encoder';\nexport { MapTypecheckError, MichelsonMap, UnitValue } from '@taquito/michelson-encoder';\nimport { ml2mic, sexp2mic, encodeExpr } from '@taquito/utils';\nimport { ReplaySubject, defer, timer, from, Subject, Observable } from 'rxjs';\nimport { switchMap, filter, first, tap, map, mapTo, switchMapTo, shareReplay, takeUntil, pluck, concatMap, distinctUntilKeyChanged, publishReplay, refCount } from 'rxjs/operators';\nimport BigNumber from 'bignumber.js';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\n\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nfunction __rest(s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\n\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nfunction __generator(thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n}\n\nfunction __values(o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n      i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n}\n\nfunction __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n}\n\nfunction __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n\n  return ar;\n}\n\nvar UnconfiguredSignerError =\n/** @class */\nfunction () {\n  function UnconfiguredSignerError() {\n    this.name = 'UnconfiguredSignerError';\n    this.message = 'No signer has been configured. Please configure one by calling setProvider({signer}) on your TezosToolkit instance.';\n  }\n\n  return UnconfiguredSignerError;\n}();\n/**\r\n * @description Default signer implementation which does nothing and produce invalid signature\r\n */\n\n\nvar NoopSigner =\n/** @class */\nfunction () {\n  function NoopSigner() {}\n\n  NoopSigner.prototype.publicKey = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        throw new UnconfiguredSignerError();\n      });\n    });\n  };\n\n  NoopSigner.prototype.publicKeyHash = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        throw new UnconfiguredSignerError();\n      });\n    });\n  };\n\n  NoopSigner.prototype.secretKey = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        throw new UnconfiguredSignerError();\n      });\n    });\n  };\n\n  NoopSigner.prototype.sign = function (_bytes, _watermark) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        throw new UnconfiguredSignerError();\n      });\n    });\n  };\n\n  return NoopSigner;\n}();\n\nvar RpcForger =\n/** @class */\nfunction () {\n  function RpcForger(context) {\n    this.context = context;\n  }\n\n  RpcForger.prototype.forge = function (_a) {\n    var branch = _a.branch,\n        contents = _a.contents;\n    return this.context.rpc.forgeOperations({\n      branch: branch,\n      contents: contents\n    });\n  };\n\n  return RpcForger;\n}();\n\nvar RpcInjector =\n/** @class */\nfunction () {\n  function RpcInjector(context) {\n    this.context = context;\n  }\n\n  RpcInjector.prototype.inject = function (signedOperationBytes) {\n    return this.context.rpc.injectOperation(signedOperationBytes);\n  };\n\n  return RpcInjector;\n}();\n\nvar defaultConfig = {\n  confirmationPollingIntervalSecond: 10,\n  defaultConfirmationCount: 1,\n  confirmationPollingTimeoutSecond: 180\n};\n/**\r\n * @description Encapsulate common service used throughout different part of the library\r\n */\n\nvar Context =\n/** @class */\nfunction () {\n  function Context(_rpcClient, _signer, _proto, _config, forger, injector) {\n    if (_rpcClient === void 0) {\n      _rpcClient = new RpcClient();\n    }\n\n    if (_signer === void 0) {\n      _signer = new NoopSigner();\n    }\n\n    this._rpcClient = _rpcClient;\n    this._signer = _signer;\n    this._proto = _proto;\n    this._config = _config;\n    this.config = _config;\n    this._forger = forger ? forger : new RpcForger(this);\n    this._injector = injector ? injector : new RpcInjector(this);\n  }\n\n  Object.defineProperty(Context.prototype, \"config\", {\n    get: function () {\n      return this._config;\n    },\n    set: function (value) {\n      this._config = __assign(__assign({}, defaultConfig), value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Context.prototype, \"rpc\", {\n    get: function () {\n      return this._rpcClient;\n    },\n    set: function (value) {\n      this._rpcClient = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Context.prototype, \"injector\", {\n    get: function () {\n      return this._injector;\n    },\n    set: function (value) {\n      this._injector = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Context.prototype, \"forger\", {\n    get: function () {\n      return this._forger;\n    },\n    set: function (value) {\n      this._forger = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Context.prototype, \"signer\", {\n    get: function () {\n      return this._signer;\n    },\n    set: function (value) {\n      this._signer = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Context.prototype, \"proto\", {\n    get: function () {\n      return this._proto;\n    },\n    set: function (value) {\n      this._proto = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Context.prototype.isAnyProtocolActive = function (protocol) {\n    if (protocol === void 0) {\n      protocol = [];\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var next_protocol;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this._proto) return [3\n            /*break*/\n            , 1];\n            return [2\n            /*return*/\n            , protocol.includes(this._proto)];\n\n          case 1:\n            return [4\n            /*yield*/\n            , this.rpc.getBlockMetadata()];\n\n          case 2:\n            next_protocol = _a.sent().next_protocol;\n            return [2\n            /*return*/\n            , protocol.includes(next_protocol)];\n        }\n      });\n    });\n  };\n  /**\r\n   * @description Create a copy of the current context. Useful when you have long running operation and you do not want a context change to affect the operation\r\n   */\n\n\n  Context.prototype.clone = function () {\n    return new Context(this.rpc, this.signer, this.proto, this.config, this.forger, this._injector);\n  };\n\n  return Context;\n}();\n/**\r\n * @description Utility class to interact with Tezos operations\r\n */\n\n\nvar Operation =\n/** @class */\nfunction () {\n  /**\r\n   *\r\n   * @param hash Operation hash\r\n   * @param raw Raw operation that was injected\r\n   * @param context Taquito context allowing access to rpc and signer\r\n   */\n  function Operation(hash, raw, results, context) {\n    var _this = this;\n\n    this.hash = hash;\n    this.raw = raw;\n    this.results = results;\n    this.context = context;\n    this._pollingConfig$ = new ReplaySubject(1);\n    this._currentHeadPromise = undefined; // Caching the current head for one second\n\n    this.currentHead$ = defer(function () {\n      if (!_this._currentHeadPromise) {\n        _this._currentHeadPromise = _this.context.rpc.getBlock();\n        timer(1000).pipe(first()).subscribe(function () {\n          _this._currentHeadPromise = undefined;\n        });\n      }\n\n      return from(_this._currentHeadPromise);\n    }); // Polling observable that emit until timeout is reached\n\n    this.polling$ = defer(function () {\n      return _this._pollingConfig$.pipe(tap(function (_a) {\n        var timeout = _a.timeout,\n            interval = _a.interval;\n\n        if (timeout <= 0) {\n          throw new Error('Timeout must be more than 0');\n        }\n\n        if (interval <= 0) {\n          throw new Error('Interval must be more than 0');\n        }\n      }), map(function (config) {\n        return __assign(__assign({}, config), {\n          timeoutAt: Math.ceil(config.timeout / config.interval) + 1,\n          count: 0\n        });\n      }), switchMap(function (config) {\n        return timer(0, config.interval * 1000).pipe(mapTo(config));\n      }), tap(function (config) {\n        config.count++;\n\n        if (config.count > config.timeoutAt) {\n          throw new Error(\"Confirmation polling timed out\");\n        }\n      }));\n    }); // Observable that emit once operation is seen in a block\n\n    this.confirmed$ = this.polling$.pipe(switchMapTo(this.currentHead$), map(function (head) {\n      for (var i = 3; i >= 0; i--) {\n        head.operations[i].forEach(function (op) {\n          if (op.hash === _this.hash) {\n            _this._foundAt = head.header.level;\n          }\n        });\n      }\n\n      if (head.header.level - _this._foundAt >= 0) {\n        return _this._foundAt;\n      }\n    }), filter(function (x) {\n      return x !== undefined;\n    }), first(), shareReplay());\n    this._foundAt = Number.POSITIVE_INFINITY;\n    this.confirmed$.pipe(first()).subscribe();\n  }\n\n  Object.defineProperty(Operation.prototype, \"includedInBlock\", {\n    get: function () {\n      return this._foundAt;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Operation.prototype, \"status\", {\n    get: function () {\n      return this.results.map(function (result) {\n        if (result.metadata && result.metadata.operation_result) {\n          return result.metadata.operation_result.status;\n        } else {\n          return 'unknown';\n        }\n      })[0] || 'unknown';\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   *\r\n   * @param confirmations [0] Number of confirmation to wait for\r\n   * @param interval [10] Polling interval\r\n   * @param timeout [180] Timeout\r\n   */\n\n  Operation.prototype.confirmation = function (confirmations, interval, timeout) {\n    var _this = this;\n\n    if (typeof confirmations !== 'undefined' && confirmations < 1) {\n      throw new Error('Confirmation count must be at least 1');\n    }\n\n    var _a = this.context.config,\n        defaultConfirmationCount = _a.defaultConfirmationCount,\n        confirmationPollingIntervalSecond = _a.confirmationPollingIntervalSecond,\n        confirmationPollingTimeoutSecond = _a.confirmationPollingTimeoutSecond;\n\n    this._pollingConfig$.next({\n      interval: interval || confirmationPollingIntervalSecond,\n      timeout: timeout || confirmationPollingTimeoutSecond\n    });\n\n    var conf = confirmations !== undefined ? confirmations : defaultConfirmationCount;\n    return new Promise(function (resolve, reject) {\n      _this.confirmed$.pipe(switchMap(function () {\n        return _this.polling$;\n      }), switchMap(function () {\n        return _this.currentHead$;\n      }), filter(function (head) {\n        return head.header.level - _this._foundAt >= conf - 1;\n      }), first()).subscribe(function (_) {\n        resolve(_this._foundAt + (conf - 1));\n      }, reject);\n    });\n  };\n\n  return Operation;\n}();\n/**\r\n * @description Delegation operation provide utility function to fetch newly issued delegation\r\n *\r\n * @warn Currently support only one delegation per operation\r\n */\n\n\nvar DelegateOperation =\n/** @class */\nfunction (_super) {\n  __extends(DelegateOperation, _super);\n\n  function DelegateOperation(hash, params, source, raw, results, context) {\n    var _this = _super.call(this, hash, raw, results, context) || this;\n\n    _this.params = params;\n    _this.source = source;\n    return _this;\n  }\n\n  Object.defineProperty(DelegateOperation.prototype, \"operationResults\", {\n    get: function () {\n      var delegationOp = Array.isArray(this.results) && this.results.find(function (op) {\n        return op.kind === 'delegation';\n      });\n      var result = delegationOp && delegationOp.metadata && delegationOp.metadata.operation_result;\n      return result ? result : undefined;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DelegateOperation.prototype, \"delegate\", {\n    get: function () {\n      return this.delegate;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DelegateOperation.prototype, \"isRegisterOperation\", {\n    get: function () {\n      return this.delegate === this.source;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DelegateOperation.prototype, \"fee\", {\n    get: function () {\n      return this.params.fee;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DelegateOperation.prototype, \"gasLimit\", {\n    get: function () {\n      return this.params.gas_limit;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DelegateOperation.prototype, \"storageLimit\", {\n    get: function () {\n      return this.params.storage_limit;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DelegateOperation.prototype, \"consumedGas\", {\n    get: function () {\n      var consumedGas = this.operationResults && this.operationResults.consumed_gas;\n      return consumedGas ? consumedGas : undefined;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DelegateOperation.prototype, \"errors\", {\n    get: function () {\n      return this.operationResults && this.operationResults.errors;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return DelegateOperation;\n}(Operation);\n\nvar DEFAULT_GAS_LIMIT;\n\n(function (DEFAULT_GAS_LIMIT) {\n  DEFAULT_GAS_LIMIT[DEFAULT_GAS_LIMIT[\"DELEGATION\"] = 10600] = \"DELEGATION\";\n  DEFAULT_GAS_LIMIT[DEFAULT_GAS_LIMIT[\"ORIGINATION\"] = 10600] = \"ORIGINATION\";\n  DEFAULT_GAS_LIMIT[DEFAULT_GAS_LIMIT[\"TRANSFER\"] = 10600] = \"TRANSFER\";\n  DEFAULT_GAS_LIMIT[DEFAULT_GAS_LIMIT[\"REVEAL\"] = 10600] = \"REVEAL\";\n})(DEFAULT_GAS_LIMIT || (DEFAULT_GAS_LIMIT = {}));\n\nvar DEFAULT_FEE;\n\n(function (DEFAULT_FEE) {\n  DEFAULT_FEE[DEFAULT_FEE[\"DELEGATION\"] = 1257] = \"DELEGATION\";\n  DEFAULT_FEE[DEFAULT_FEE[\"ORIGINATION\"] = 10000] = \"ORIGINATION\";\n  DEFAULT_FEE[DEFAULT_FEE[\"TRANSFER\"] = 10000] = \"TRANSFER\";\n  DEFAULT_FEE[DEFAULT_FEE[\"REVEAL\"] = 1420] = \"REVEAL\";\n})(DEFAULT_FEE || (DEFAULT_FEE = {}));\n\nvar DEFAULT_STORAGE_LIMIT;\n\n(function (DEFAULT_STORAGE_LIMIT) {\n  DEFAULT_STORAGE_LIMIT[DEFAULT_STORAGE_LIMIT[\"DELEGATION\"] = 0] = \"DELEGATION\";\n  DEFAULT_STORAGE_LIMIT[DEFAULT_STORAGE_LIMIT[\"ORIGINATION\"] = 257] = \"ORIGINATION\";\n  DEFAULT_STORAGE_LIMIT[DEFAULT_STORAGE_LIMIT[\"TRANSFER\"] = 257] = \"TRANSFER\";\n  DEFAULT_STORAGE_LIMIT[DEFAULT_STORAGE_LIMIT[\"REVEAL\"] = 0] = \"REVEAL\";\n})(DEFAULT_STORAGE_LIMIT || (DEFAULT_STORAGE_LIMIT = {}));\n\nvar Protocols;\n\n(function (Protocols) {\n  Protocols[\"Pt24m4xi\"] = \"Pt24m4xiPbLDhVgVfABUjirbmda3yohdN82Sp9FeuAXJ4eV9otd\";\n  Protocols[\"PsBABY5H\"] = \"PsBABY5HQTSkA4297zNHfsZNKtxULfL18y95qb3m53QJiXGmrbU\";\n  Protocols[\"PsBabyM1\"] = \"PsBabyM1eUXZseaJdmXFApDSBqj8YBfwELoxZHHW77EMcAbbwAS\";\n  Protocols[\"PsCARTHA\"] = \"PsCARTHAGazKbHtnKfLzQg3kms52kSRpgnDY982a9oYsSXRLQEb\";\n})(Protocols || (Protocols = {}));\n\nvar protocols = {\n  '004': [Protocols.Pt24m4xi],\n  '005': [Protocols.PsBABY5H, Protocols.PsBabyM1],\n  '006': [Protocols.PsCARTHA]\n};\n\nvar isErrorWithMessage = function (error) {\n  return 'with' in error;\n};\n\nvar TezosOperationError =\n/** @class */\nfunction () {\n  function TezosOperationError(errors) {\n    this.errors = errors;\n    this.name = 'TezosOperationError'; // Last error is 'often' the one with more detail\n\n    var lastError = errors[errors.length - 1];\n    this.id = lastError.id;\n    this.kind = lastError.kind;\n    this.message = \"(\" + this.kind + \") \" + this.id;\n\n    if (isErrorWithMessage(lastError) && lastError.with.string) {\n      this.message = lastError.with.string;\n    }\n  }\n\n  return TezosOperationError;\n}();\n\nvar TezosPreapplyFailureError =\n/** @class */\nfunction () {\n  function TezosPreapplyFailureError(result) {\n    this.result = result;\n    this.name = 'TezosPreapplyFailureError';\n    this.message = 'Preapply returned an unexpected result';\n  }\n\n  return TezosPreapplyFailureError;\n}();\n\nvar flattenOperationResult = function (response) {\n  var results = Array.isArray(response) ? response : [response];\n  var returnedResults = [];\n\n  for (var i = 0; i < results.length; i++) {\n    for (var j = 0; j < results[i].contents.length; j++) {\n      var content = results[i].contents[j];\n\n      if ('metadata' in content && typeof content.metadata.operation_result !== 'undefined') {\n        returnedResults.push(content.metadata.operation_result);\n\n        if (Array.isArray(content.metadata.internal_operation_results)) {\n          content.metadata.internal_operation_results.forEach(function (x) {\n            return returnedResults.push(x.result);\n          });\n        }\n      }\n    }\n  }\n\n  return returnedResults;\n};\n/***\r\n * @description Flatten all error from preapply response (including internal error)\r\n */\n\n\nvar flattenErrors = function (response, status) {\n  var e_1, _a;\n\n  if (status === void 0) {\n    status = 'failed';\n  }\n\n  var results = Array.isArray(response) ? response : [response];\n  var errors = []; // Transaction that do not fail will be backtracked in case one failure occur\n\n  for (var i = 0; i < results.length; i++) {\n    for (var j = 0; j < results[i].contents.length; j++) {\n      var content = results[i].contents[j];\n\n      if ('metadata' in content) {\n        if (typeof content.metadata.operation_result !== 'undefined' && content.metadata.operation_result.status === status) {\n          errors = errors.concat(content.metadata.operation_result.errors || []);\n        }\n\n        if (Array.isArray(content.metadata.internal_operation_results)) {\n          try {\n            for (var _b = (e_1 = void 0, __values(content.metadata.internal_operation_results)), _c = _b.next(); !_c.done; _c = _b.next()) {\n              var internalResult = _c.value;\n\n              if ('result' in internalResult && internalResult.result.status === status) {\n                errors = errors.concat(internalResult.result.errors || []);\n              }\n            }\n          } catch (e_1_1) {\n            e_1 = {\n              error: e_1_1\n            };\n          } finally {\n            try {\n              if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            } finally {\n              if (e_1) throw e_1.error;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return errors;\n};\n\nvar isOpWithFee = function (op) {\n  return ['transaction', 'delegation', 'origination', 'reveal'].indexOf(op.kind) !== -1;\n};\n\nvar isOpRequireReveal = function (op) {\n  return ['transaction', 'delegation', 'origination'].indexOf(op.kind) !== -1;\n};\n\nvar OperationEmitter =\n/** @class */\nfunction () {\n  function OperationEmitter(context) {\n    this.context = context;\n  }\n\n  Object.defineProperty(OperationEmitter.prototype, \"rpc\", {\n    get: function () {\n      return this.context.rpc;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OperationEmitter.prototype, \"signer\", {\n    get: function () {\n      return this.context.signer;\n    },\n    enumerable: true,\n    configurable: true\n  }); // Originally from sotez (Copyright (c) 2018 Andrew Kishino)\n\n  OperationEmitter.prototype.prepareOperation = function (_a) {\n    var operation = _a.operation,\n        source = _a.source;\n    return __awaiter(this, void 0, void 0, function () {\n      var counter, counters, requiresReveal, ops, head, blockHeaderPromise, blockMetaPromise, publicKeyHash, counterPromise, managerPromise, i, counter_1, _b, header, metadata, headCounter, manager, haveManager, reveal, _c, getFee, getSource, constructOps, branch, contents, protocol;\n\n      return __generator(this, function (_d) {\n        switch (_d.label) {\n          case 0:\n            counters = {};\n            requiresReveal = false;\n            ops = [];\n            blockHeaderPromise = this.rpc.getBlockHeader();\n            blockMetaPromise = this.rpc.getBlockMetadata();\n\n            if (Array.isArray(operation)) {\n              ops = __spread(operation);\n            } else {\n              ops = [operation];\n            }\n\n            return [4\n            /*yield*/\n            , this.signer.publicKeyHash()];\n\n          case 1:\n            publicKeyHash = _d.sent();\n            counterPromise = Promise.resolve(undefined);\n            managerPromise = Promise.resolve(undefined);\n            i = 0;\n            _d.label = 2;\n\n          case 2:\n            if (!(i < ops.length)) return [3\n            /*break*/\n            , 5];\n            if (!isOpRequireReveal(ops[i])) return [3\n            /*break*/\n            , 4];\n            requiresReveal = true;\n            return [4\n            /*yield*/\n            , this.rpc.getContract(publicKeyHash)];\n\n          case 3:\n            counter_1 = _d.sent().counter;\n            counterPromise = Promise.resolve(counter_1);\n            managerPromise = this.rpc.getManagerKey(publicKeyHash);\n            return [3\n            /*break*/\n            , 5];\n\n          case 4:\n            i++;\n            return [3\n            /*break*/\n            , 2];\n\n          case 5:\n            return [4\n            /*yield*/\n            , Promise.all([blockHeaderPromise, blockMetaPromise, counterPromise, managerPromise])];\n\n          case 6:\n            _b = __read.apply(void 0, [_d.sent(), 4]), header = _b[0], metadata = _b[1], headCounter = _b[2], manager = _b[3];\n\n            if (!header) {\n              throw new Error('Unable to latest block header');\n            }\n\n            if (!metadata) {\n              throw new Error('Unable to fetch latest metadata');\n            }\n\n            head = header;\n            if (!requiresReveal) return [3\n            /*break*/\n            , 8];\n            haveManager = manager && typeof manager === 'object' ? !!manager.key : !!manager;\n            if (!!haveManager) return [3\n            /*break*/\n            , 8];\n            _c = {\n              kind: OpKind.REVEAL,\n              fee: DEFAULT_FEE.REVEAL\n            };\n            return [4\n            /*yield*/\n            , this.signer.publicKey()];\n\n          case 7:\n            reveal = (_c.public_key = _d.sent(), _c.source = publicKeyHash, _c.gas_limit = DEFAULT_GAS_LIMIT.REVEAL, _c.storage_limit = DEFAULT_STORAGE_LIMIT.REVEAL, _c);\n            ops.unshift(reveal);\n            _d.label = 8;\n\n          case 8:\n            counter = parseInt(headCounter || '0', 10);\n\n            if (!counters[publicKeyHash] || counters[publicKeyHash] < counter) {\n              counters[publicKeyHash] = counter;\n            }\n\n            getFee = function (op) {\n              var opCounter = ++counters[publicKeyHash];\n              return {\n                counter: \"\" + opCounter,\n                // tslint:disable-next-line: strict-type-predicates\n                fee: typeof op.fee === 'undefined' ? '0' : \"\" + op.fee,\n                // tslint:disable-next-line: strict-type-predicates\n                gas_limit: typeof op.gas_limit === 'undefined' ? '0' : \"\" + op.gas_limit,\n                // tslint:disable-next-line: strict-type-predicates\n                storage_limit: typeof op.storage_limit === 'undefined' ? '0' : \"\" + op.storage_limit\n              };\n            };\n\n            getSource = function (op) {\n              return {\n                source: typeof op.source === 'undefined' ? source || publicKeyHash : op.source\n              };\n            };\n\n            constructOps = function (cOps) {\n              // tslint:disable strict-type-predicates\n              return cOps.map(function (op) {\n                switch (op.kind) {\n                  case OpKind.ACTIVATION:\n                    return __assign({}, op);\n\n                  case OpKind.REVEAL:\n                    return __assign(__assign(__assign({}, op), getSource(op)), getFee(op));\n\n                  case OpKind.ORIGINATION:\n                    return __assign(__assign(__assign(__assign({}, op), {\n                      balance: typeof op.balance !== 'undefined' ? \"\" + op.balance : '0'\n                    }), getSource(op)), getFee(op));\n\n                  case OpKind.TRANSACTION:\n                    var cops = __assign(__assign(__assign(__assign({}, op), {\n                      amount: typeof op.amount !== 'undefined' ? \"\" + op.amount : '0'\n                    }), getSource(op)), getFee(op));\n\n                    if (cops.source.toLowerCase().startsWith('kt1')) {\n                      throw new Error(\"KT1 addresses are not supported as source since \" + Protocols.PsBabyM1);\n                    }\n\n                    return cops;\n\n                  case OpKind.DELEGATION:\n                    return __assign(__assign(__assign({}, op), getSource(op)), getFee(op));\n\n                  default:\n                    throw new Error('Unsupported operation');\n                }\n              });\n            };\n\n            branch = head.hash;\n            contents = constructOps(ops);\n            protocol = metadata.next_protocol;\n            return [2\n            /*return*/\n            , {\n              opOb: {\n                branch: branch,\n                contents: contents,\n                protocol: protocol\n              },\n              counter: counter\n            }];\n        }\n      });\n    });\n  };\n\n  OperationEmitter.prototype.prepareAndForge = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      var prepared;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.prepareOperation(params)];\n\n          case 1:\n            prepared = _a.sent();\n            return [2\n            /*return*/\n            , this.forge(prepared)];\n        }\n      });\n    });\n  };\n\n  OperationEmitter.prototype.forge = function (_a) {\n    var _b = _a.opOb,\n        branch = _b.branch,\n        contents = _b.contents,\n        protocol = _b.protocol,\n        counter = _a.counter;\n    return __awaiter(this, void 0, void 0, function () {\n      var forgedBytes;\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.context.forger.forge({\n              branch: branch,\n              contents: contents\n            })];\n\n          case 1:\n            forgedBytes = _c.sent();\n            return [2\n            /*return*/\n            , {\n              opbytes: forgedBytes,\n              opOb: {\n                branch: branch,\n                contents: contents,\n                protocol: protocol\n              },\n              counter: counter\n            }];\n        }\n      });\n    });\n  };\n\n  OperationEmitter.prototype.simulate = function (op) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _a = {};\n            return [4\n            /*yield*/\n            , this.rpc.runOperation(op)];\n\n          case 1:\n            return [2\n            /*return*/\n            , (_a.opResponse = _b.sent(), _a.op = op, _a.context = this.context.clone(), _a)];\n        }\n      });\n    });\n  };\n\n  OperationEmitter.prototype.estimate = function (_a, estimator) {\n    var fee = _a.fee,\n        gasLimit = _a.gasLimit,\n        storageLimit = _a.storageLimit,\n        rest = __rest(_a, [\"fee\", \"gasLimit\", \"storageLimit\"]);\n\n    return __awaiter(this, void 0, void 0, function () {\n      var calculatedFee, calculatedGas, calculatedStorage, estimation;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            calculatedFee = fee;\n            calculatedGas = gasLimit;\n            calculatedStorage = storageLimit;\n            if (!(fee === undefined || gasLimit === undefined || storageLimit === undefined)) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , estimator(__assign({\n              fee: fee,\n              gasLimit: gasLimit,\n              storageLimit: storageLimit\n            }, rest))];\n\n          case 1:\n            estimation = _b.sent();\n\n            if (calculatedFee === undefined) {\n              calculatedFee = estimation.suggestedFeeMutez;\n            }\n\n            if (calculatedGas === undefined) {\n              calculatedGas = estimation.gasLimit;\n            }\n\n            if (calculatedStorage === undefined) {\n              calculatedStorage = estimation.storageLimit;\n            }\n\n            _b.label = 2;\n\n          case 2:\n            return [2\n            /*return*/\n            , {\n              fee: calculatedFee,\n              gasLimit: calculatedGas,\n              storageLimit: calculatedStorage\n            }];\n        }\n      });\n    });\n  };\n\n  OperationEmitter.prototype.signAndInject = function (forgedBytes) {\n    return __awaiter(this, void 0, void 0, function () {\n      var signed, opResponse, results, i, j, errors, _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.signer.sign(forgedBytes.opbytes, new Uint8Array([3]))];\n\n          case 1:\n            signed = _b.sent();\n            forgedBytes.opbytes = signed.sbytes;\n            forgedBytes.opOb.signature = signed.prefixSig;\n            opResponse = [];\n            return [4\n            /*yield*/\n            , this.rpc.preapplyOperations([forgedBytes.opOb])];\n\n          case 2:\n            results = _b.sent();\n\n            if (!Array.isArray(results)) {\n              throw new TezosPreapplyFailureError(results);\n            }\n\n            for (i = 0; i < results.length; i++) {\n              for (j = 0; j < results[i].contents.length; j++) {\n                opResponse.push(results[i].contents[j]);\n              }\n            }\n\n            errors = flattenErrors(results);\n\n            if (errors.length) {\n              // @ts-ignore\n              throw new TezosOperationError(errors);\n            }\n\n            _a = {};\n            return [4\n            /*yield*/\n            , this.context.injector.inject(forgedBytes.opbytes)];\n\n          case 3:\n            return [2\n            /*return*/\n            , (_a.hash = _b.sent(), _a.forgedBytes = forgedBytes, _a.opResponse = opResponse, _a.context = this.context.clone(), _a)];\n        }\n      });\n    });\n  };\n\n  return OperationEmitter;\n}();\n/**\r\n * @description Origination operation provide utility function to fetch newly originated contract\r\n *\r\n * @warn Currently support only one origination per operation\r\n */\n\n\nvar OriginationOperation =\n/** @class */\nfunction (_super) {\n  __extends(OriginationOperation, _super);\n\n  function OriginationOperation(hash, params, raw, results, context, contractProvider) {\n    var _this = _super.call(this, hash, raw, results, context) || this;\n\n    _this.params = params;\n    _this.contractProvider = contractProvider;\n    var originatedContracts = _this.operationResults && _this.operationResults.originated_contracts;\n\n    if (Array.isArray(originatedContracts)) {\n      _this.contractAddress = originatedContracts[0];\n    }\n\n    return _this;\n  }\n\n  Object.defineProperty(OriginationOperation.prototype, \"operationResults\", {\n    get: function () {\n      var originationOp = Array.isArray(this.results) && this.results.find(function (op) {\n        return op.kind === 'origination';\n      });\n      var result = originationOp && originationOp.metadata && originationOp.metadata.operation_result;\n      return result ? result : undefined;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OriginationOperation.prototype, \"fee\", {\n    get: function () {\n      return this.params.fee;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OriginationOperation.prototype, \"gasLimit\", {\n    get: function () {\n      return this.params.gas_limit;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OriginationOperation.prototype, \"storageLimit\", {\n    get: function () {\n      return this.params.storage_limit;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OriginationOperation.prototype, \"consumedGas\", {\n    get: function () {\n      var consumedGas = this.operationResults && this.operationResults.consumed_gas;\n      return consumedGas ? consumedGas : undefined;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OriginationOperation.prototype, \"storageDiff\", {\n    get: function () {\n      var storageDiff = this.operationResults && this.operationResults.paid_storage_size_diff;\n      return storageDiff ? storageDiff : undefined;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OriginationOperation.prototype, \"storageSize\", {\n    get: function () {\n      var storageSize = this.operationResults && this.operationResults.storage_size;\n      return storageSize ? storageSize : undefined;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OriginationOperation.prototype, \"errors\", {\n    get: function () {\n      return this.operationResults && this.operationResults.errors;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * @description Provide the contract abstract of the newly originated contract\r\n   */\n\n  OriginationOperation.prototype.contract = function (confirmations, interval, timeout) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this.contractAddress) {\n              throw new Error('No contract was originated in this operation');\n            }\n\n            return [4\n            /*yield*/\n            , this.confirmation(confirmations, interval, timeout)];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            , this.contractProvider.at(this.contractAddress)];\n        }\n      });\n    });\n  };\n\n  return OriginationOperation;\n}(Operation);\n/**\r\n * @description Transaction operation provides utility functions to fetch a newly issued transaction\r\n *\r\n * @warn Currently supports one transaction per operation\r\n */\n\n\nvar TransactionOperation =\n/** @class */\nfunction (_super) {\n  __extends(TransactionOperation, _super);\n\n  function TransactionOperation(hash, params, source, raw, results, context) {\n    var _this = _super.call(this, hash, raw, results, context) || this;\n\n    _this.params = params;\n    _this.source = source;\n    return _this;\n  }\n\n  Object.defineProperty(TransactionOperation.prototype, \"operationResults\", {\n    get: function () {\n      var transactionOp = Array.isArray(this.results) && this.results.find(function (op) {\n        return op.kind === 'transaction';\n      });\n      return transactionOp ? [transactionOp] : [];\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TransactionOperation.prototype, \"amount\", {\n    get: function () {\n      return new BigNumber(this.params.amount);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TransactionOperation.prototype, \"destination\", {\n    get: function () {\n      return this.params.destination;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TransactionOperation.prototype, \"fee\", {\n    get: function () {\n      return this.params.fee;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TransactionOperation.prototype, \"gasLimit\", {\n    get: function () {\n      return this.params.gas_limit;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TransactionOperation.prototype, \"storageLimit\", {\n    get: function () {\n      return this.params.storage_limit;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  TransactionOperation.prototype.sumProp = function (arr, prop) {\n    return arr.reduce(function (prev, current) {\n      return prop in current ? Number(current[prop]) + prev : prev;\n    }, 0);\n  };\n\n  Object.defineProperty(TransactionOperation.prototype, \"consumedGas\", {\n    get: function () {\n      return String(this.sumProp(flattenOperationResult({\n        contents: this.operationResults\n      }), 'consumed_gas'));\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TransactionOperation.prototype, \"storageDiff\", {\n    get: function () {\n      return String(this.sumProp(flattenOperationResult({\n        contents: this.operationResults\n      }), 'paid_storage_size_diff'));\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TransactionOperation.prototype, \"storageSize\", {\n    get: function () {\n      return String(this.sumProp(flattenOperationResult({\n        contents: this.operationResults\n      }), 'storage_size'));\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TransactionOperation.prototype, \"errors\", {\n    get: function () {\n      return flattenErrors({\n        contents: this.operationResults\n      });\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return TransactionOperation;\n}(Operation);\n\nvar InvalidParameterError =\n/** @class */\nfunction () {\n  function InvalidParameterError(smartContractMethodName, sigs, args) {\n    this.smartContractMethodName = smartContractMethodName;\n    this.sigs = sigs;\n    this.args = args;\n    this.name = 'Invalid parameters error';\n    this.message = smartContractMethodName + \" Received \" + args.length + \" arguments while expecting on of the follow signatures (\" + JSON.stringify(sigs) + \")\";\n  }\n\n  return InvalidParameterError;\n}();\n\nvar InvalidDelegationSource =\n/** @class */\nfunction () {\n  function InvalidDelegationSource(source) {\n    this.source = source;\n    this.name = 'Invalid delegation source error';\n    this.message = \"Since Babylon delegation source can no longer be a contract address \" + source + \". Please use the smart contract abstraction to set your delegate.\";\n  }\n\n  return InvalidDelegationSource;\n}();\n\nvar DEFAULT_SMART_CONTRACT_METHOD_NAME = 'main';\n/**\r\n * @description Utility class to send smart contract operation\r\n */\n\nvar ContractMethod =\n/** @class */\nfunction () {\n  function ContractMethod(provider, address, parameterSchema, name, args, isMultipleEntrypoint, isAnonymous) {\n    if (isMultipleEntrypoint === void 0) {\n      isMultipleEntrypoint = true;\n    }\n\n    if (isAnonymous === void 0) {\n      isAnonymous = false;\n    }\n\n    this.provider = provider;\n    this.address = address;\n    this.parameterSchema = parameterSchema;\n    this.name = name;\n    this.args = args;\n    this.isMultipleEntrypoint = isMultipleEntrypoint;\n    this.isAnonymous = isAnonymous;\n  }\n\n  Object.defineProperty(ContractMethod.prototype, \"schema\", {\n    /**\r\n     * @description Get the schema of the smart contract method\r\n     */\n    get: function () {\n      return this.isAnonymous ? this.parameterSchema.ExtractSchema()[this.name] : this.parameterSchema.ExtractSchema();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   *\r\n   * @description Send the smart contract operation\r\n   *\r\n   * @param Options generic operation parameter\r\n   */\n\n  ContractMethod.prototype.send = function (params) {\n    if (params === void 0) {\n      params = {};\n    }\n\n    return this.provider.transfer(this.toTransferParams(params));\n  };\n  /**\r\n   *\r\n   * @description Create transfer params to be used with TezosToolkit.contract.transfer methods\r\n   *\r\n   * @param Options generic transfer operation parameters\r\n   */\n\n\n  ContractMethod.prototype.toTransferParams = function (_a) {\n    var _b, _c;\n\n    var _d = _a === void 0 ? {} : _a,\n        fee = _d.fee,\n        gasLimit = _d.gasLimit,\n        storageLimit = _d.storageLimit,\n        source = _d.source,\n        _e = _d.amount,\n        amount = _e === void 0 ? 0 : _e,\n        _f = _d.mutez,\n        mutez = _f === void 0 ? false : _f;\n\n    var fullTransferParams = {\n      to: this.address,\n      amount: amount,\n      fee: fee,\n      mutez: mutez,\n      source: source,\n      gasLimit: gasLimit,\n      storageLimit: storageLimit,\n      parameter: {\n        entrypoint: this.isMultipleEntrypoint ? this.name : 'default',\n        value: this.isAnonymous ? (_b = this.parameterSchema).Encode.apply(_b, __spread([this.name], this.args)) : (_c = this.parameterSchema).Encode.apply(_c, __spread(this.args))\n      },\n      rawParam: true\n    };\n    return fullTransferParams;\n  };\n\n  return ContractMethod;\n}();\n\nvar validateArgs = function (args, schema, name) {\n  var sigs = schema.ExtractSignatures();\n\n  if (!sigs.find(function (x) {\n    return x.length === args.length;\n  })) {\n    throw new InvalidParameterError(name, sigs, args);\n  }\n};\n/**\r\n * @description Smart contract abstraction\r\n */\n\n\nvar Contract =\n/** @class */\nfunction () {\n  function Contract(address, script, provider, entrypoints) {\n    this.address = address;\n    this.script = script;\n    this.provider = provider;\n    this.entrypoints = entrypoints;\n    /**\r\n     * @description Contains methods that are implemented by the target Tezos Smart Contract, and offers the user to call the Smart Contract methods as if they were native TS/JS methods.\r\n     * NB: if the contract contains annotation it will include named properties; if not it will be indexed by a number.\r\n     *\r\n     */\n\n    this.methods = {};\n    this.schema = Schema.fromRPCResponse({\n      script: this.script\n    });\n    this.parameterSchema = ParameterSchema.fromRPCResponse({\n      script: this.script\n    });\n\n    this._initializeMethods(address, provider, this.entrypoints.entrypoints);\n  }\n\n  Contract.prototype._initializeMethods = function (address, provider, entrypoints) {\n    var _this = this;\n\n    var parameterSchema = this.parameterSchema;\n    var keys = Object.keys(entrypoints);\n\n    if (parameterSchema.isMultipleEntryPoint) {\n      keys.forEach(function (smartContractMethodName) {\n        var method = function () {\n          var args = [];\n\n          for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n          }\n\n          var smartContractMethodSchema = new ParameterSchema(entrypoints[smartContractMethodName]);\n          validateArgs(args, smartContractMethodSchema, smartContractMethodName);\n          return new ContractMethod(provider, address, smartContractMethodSchema, smartContractMethodName, args);\n        };\n\n        _this.methods[smartContractMethodName] = method;\n      }); // Deal with methods with no annotations which were not discovered by the RPC endpoint\n      // Methods with no annotations are discovered using parameter schema\n\n      var anonymousMethods = Object.keys(parameterSchema.ExtractSchema()).filter(function (key) {\n        return Object.keys(entrypoints).indexOf(key) === -1;\n      });\n      anonymousMethods.forEach(function (smartContractMethodName) {\n        var method = function () {\n          var args = [];\n\n          for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n          }\n\n          validateArgs(__spread([smartContractMethodName], args), parameterSchema, smartContractMethodName);\n          return new ContractMethod(provider, address, parameterSchema, smartContractMethodName, args, false, true);\n        };\n\n        _this.methods[smartContractMethodName] = method;\n      });\n    } else {\n      var smartContractMethodSchema_1 = this.parameterSchema;\n\n      var method = function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        validateArgs(args, parameterSchema, DEFAULT_SMART_CONTRACT_METHOD_NAME);\n        return new ContractMethod(provider, address, smartContractMethodSchema_1, DEFAULT_SMART_CONTRACT_METHOD_NAME, args, false);\n      };\n\n      this.methods[DEFAULT_SMART_CONTRACT_METHOD_NAME] = method;\n    }\n  };\n  /**\r\n   * @description Return a friendly representation of the smart contract storage\r\n   */\n\n\n  Contract.prototype.storage = function () {\n    return this.provider.getStorage(this.address, this.schema);\n  };\n  /**\r\n   *\r\n   * @description Return a friendly representation of the smart contract big map value\r\n   *\r\n   * @param key BigMap key to fetch\r\n   */\n\n\n  Contract.prototype.bigMap = function (key) {\n    // tslint:disable-next-line: deprecation\n    return this.provider.getBigMapKey(this.address, key, this.schema);\n  };\n\n  return Contract;\n}();\n\nvar TZ_DECIMALS = 6;\nvar MTZ_DECIMALS = 3;\n\nfunction getDecimal(format) {\n  switch (format) {\n    case 'tz':\n      return TZ_DECIMALS;\n\n    case 'mtz':\n      return MTZ_DECIMALS;\n\n    case 'mutez':\n    default:\n      return 0;\n  }\n}\n\nfunction format(from, to, amount) {\n  if (from === void 0) {\n    from = 'mutez';\n  }\n\n  if (to === void 0) {\n    to = 'mutez';\n  }\n\n  var bigNum = new BigNumber(amount);\n\n  if (bigNum.isNaN()) {\n    return amount;\n  }\n\n  return bigNum.multipliedBy(Math.pow(10, getDecimal(from))).dividedBy(Math.pow(10, getDecimal(to)));\n}\n\nvar createOriginationOperation = function (_a) {\n  var code = _a.code,\n      init = _a.init,\n      _b = _a.balance,\n      balance = _b === void 0 ? '0' : _b,\n      delegate = _a.delegate,\n      storage = _a.storage,\n      _c = _a.fee,\n      fee = _c === void 0 ? DEFAULT_FEE.ORIGINATION : _c,\n      _d = _a.gasLimit,\n      gasLimit = _d === void 0 ? DEFAULT_GAS_LIMIT.ORIGINATION : _d,\n      _e = _a.storageLimit,\n      storageLimit = _e === void 0 ? DEFAULT_STORAGE_LIMIT.ORIGINATION : _e;\n  return __awaiter(void 0, void 0, void 0, function () {\n    var contractCode, contractStorage, schema, script, operation;\n    return __generator(this, function (_f) {\n      // tslint:disable-next-line: strict-type-predicates\n      if (storage !== undefined && init !== undefined) {\n        throw new Error('Storage and Init cannot be set a the same time. Please either use storage or init but not both.');\n      }\n\n      contractCode = Array.isArray(code) ? code : ml2mic(code);\n\n      if (storage !== undefined) {\n        schema = new Schema(contractCode[1].args[0]);\n        contractStorage = schema.Encode(storage);\n      } else {\n        contractStorage = typeof init === 'string' ? sexp2mic(init) : init;\n      }\n\n      script = {\n        code: Array.isArray(code) ? code : ml2mic(code),\n        storage: contractStorage\n      };\n      operation = {\n        kind: OpKind.ORIGINATION,\n        fee: fee,\n        gas_limit: gasLimit,\n        storage_limit: storageLimit,\n        balance: format('tz', 'mutez', balance).toString(),\n        script: script\n      };\n\n      if (delegate) {\n        operation.delegate = delegate;\n      }\n\n      return [2\n      /*return*/\n      , operation];\n    });\n  });\n};\n\nvar createTransferOperation = function (_a) {\n  var to = _a.to,\n      amount = _a.amount,\n      parameter = _a.parameter,\n      _b = _a.fee,\n      fee = _b === void 0 ? DEFAULT_FEE.TRANSFER : _b,\n      _c = _a.gasLimit,\n      gasLimit = _c === void 0 ? DEFAULT_GAS_LIMIT.TRANSFER : _c,\n      _d = _a.storageLimit,\n      storageLimit = _d === void 0 ? DEFAULT_STORAGE_LIMIT.TRANSFER : _d,\n      _e = _a.mutez,\n      mutez = _e === void 0 ? false : _e,\n      _f = _a.rawParam,\n      rawParam = _f === void 0 ? false : _f;\n  return __awaiter(void 0, void 0, void 0, function () {\n    var operation;\n    return __generator(this, function (_g) {\n      operation = {\n        kind: OpKind.TRANSACTION,\n        fee: fee,\n        gas_limit: gasLimit,\n        storage_limit: storageLimit,\n        amount: mutez ? amount.toString() : format('tz', 'mutez', amount).toString(),\n        destination: to\n      };\n\n      if (parameter) {\n        operation.parameters = rawParam ? parameter : typeof parameter === 'string' ? sexp2mic(parameter) : parameter;\n      }\n\n      return [2\n      /*return*/\n      , operation];\n    });\n  });\n};\n\nvar createSetDelegateOperation = function (_a) {\n  var delegate = _a.delegate,\n      source = _a.source,\n      _b = _a.fee,\n      fee = _b === void 0 ? DEFAULT_FEE.DELEGATION : _b,\n      _c = _a.gasLimit,\n      gasLimit = _c === void 0 ? DEFAULT_GAS_LIMIT.DELEGATION : _c,\n      _d = _a.storageLimit,\n      storageLimit = _d === void 0 ? DEFAULT_STORAGE_LIMIT.DELEGATION : _d;\n  return __awaiter(void 0, void 0, void 0, function () {\n    var operation;\n    return __generator(this, function (_e) {\n      operation = {\n        kind: OpKind.DELEGATION,\n        source: source,\n        fee: fee,\n        gas_limit: gasLimit,\n        storage_limit: storageLimit,\n        delegate: delegate\n      };\n      return [2\n      /*return*/\n      , operation];\n    });\n  });\n};\n\nvar createRegisterDelegateOperation = function (_a, source) {\n  var _b = _a.fee,\n      fee = _b === void 0 ? DEFAULT_FEE.DELEGATION : _b,\n      _c = _a.gasLimit,\n      gasLimit = _c === void 0 ? DEFAULT_GAS_LIMIT.DELEGATION : _c,\n      _d = _a.storageLimit,\n      storageLimit = _d === void 0 ? DEFAULT_STORAGE_LIMIT.DELEGATION : _d;\n  return __awaiter(void 0, void 0, void 0, function () {\n    return __generator(this, function (_e) {\n      return [2\n      /*return*/\n      , {\n        kind: OpKind.DELEGATION,\n        fee: fee,\n        gas_limit: gasLimit,\n        storage_limit: storageLimit,\n        delegate: source\n      }];\n    });\n  });\n};\n\nvar BigMapAbstraction =\n/** @class */\nfunction () {\n  function BigMapAbstraction(id, schema, provider) {\n    this.id = id;\n    this.schema = schema;\n    this.provider = provider;\n  }\n\n  BigMapAbstraction.prototype.get = function (keyToEncode) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.provider.getBigMapKeyByID(this.id.toString(), keyToEncode, this.schema)];\n      });\n    });\n  };\n\n  BigMapAbstraction.prototype.toJSON = function () {\n    return this.id.toString();\n  };\n\n  BigMapAbstraction.prototype.toString = function () {\n    return this.id.toString();\n  };\n\n  return BigMapAbstraction;\n}(); // Override the default michelson encoder semantic to provide richer abstraction over storage properties\n\n\nvar smartContractAbstractionSemantic = function (provider) {\n  return {\n    // Provide a specific abstraction for BigMaps\n    big_map: function (val, code) {\n      if (!val || !('int' in val) || val.int === undefined) {\n        // Return an empty object in case of missing big map ID\n        return {};\n      } else {\n        var schema = new Schema(code);\n        return new BigMapAbstraction(new BigNumber(val.int), schema, provider);\n      }\n    }\n  };\n};\n\nvar RpcContractProvider =\n/** @class */\nfunction (_super) {\n  __extends(RpcContractProvider, _super);\n\n  function RpcContractProvider(context, estimator) {\n    var _this = _super.call(this, context) || this;\n\n    _this.estimator = estimator;\n    return _this;\n  }\n  /**\r\n   *\r\n   * @description Return a well formatted json object of the contract storage\r\n   *\r\n   * @param contract contract address you want to get the storage from\r\n   * @param schema optional schema can either be the contract script rpc response or a michelson-encoder schema\r\n   *\r\n   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-script\r\n   */\n\n\n  RpcContractProvider.prototype.getStorage = function (contract, schema) {\n    return __awaiter(this, void 0, void 0, function () {\n      var contractSchema, storage;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!!schema) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this.rpc.getScript(contract)];\n\n          case 1:\n            schema = _a.sent();\n            _a.label = 2;\n\n          case 2:\n            if (schema instanceof Schema) {\n              contractSchema = schema;\n            } else {\n              contractSchema = Schema.fromRPCResponse({\n                script: schema\n              });\n            }\n\n            return [4\n            /*yield*/\n            , this.rpc.getStorage(contract)];\n\n          case 3:\n            storage = _a.sent();\n            return [2\n            /*return*/\n            , contractSchema.Execute(storage, smartContractAbstractionSemantic(this))];\n          // Cast into T because only the caller can know the true type of the storage\n        }\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @description Return a well formatted json object of the contract big map storage\r\n   *\r\n   * @param contract contract address you want to get the storage from\r\n   * @param key contract big map key to fetch value from\r\n   * @param schema optional schema can either be the contract script rpc response or a michelson-encoder schema\r\n   *\r\n   * @deprecated Deprecated in favor of getBigMapKeyByID\r\n   *\r\n   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-script\r\n   */\n\n\n  RpcContractProvider.prototype.getBigMapKey = function (contract, key, schema) {\n    return __awaiter(this, void 0, void 0, function () {\n      var contractSchema, encodedKey, val;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!!schema) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this.rpc.getScript(contract)];\n\n          case 1:\n            schema = _a.sent();\n            _a.label = 2;\n\n          case 2:\n            if (schema instanceof Schema) {\n              contractSchema = schema;\n            } else {\n              contractSchema = Schema.fromRPCResponse({\n                script: schema\n              });\n            }\n\n            encodedKey = contractSchema.EncodeBigMapKey(key);\n            return [4\n            /*yield*/\n            , this.rpc.getBigMapKey(contract, encodedKey)];\n\n          case 3:\n            val = _a.sent();\n            return [2\n            /*return*/\n            , contractSchema.ExecuteOnBigMapValue(val)];\n          // Cast into T because only the caller can know the true type of the storage\n        }\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @description Return a well formatted json object of a big map value\r\n   *\r\n   * @param id Big Map ID\r\n   * @param keyToEncode key to query (will be encoded properly according to the schema)\r\n   * @param schema Big Map schema (can be determined using your contract type)\r\n   *\r\n   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-big-maps-big-map-id-script-expr\r\n   */\n\n\n  RpcContractProvider.prototype.getBigMapKeyByID = function (id, keyToEncode, schema) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, key, type, packed, encodedExpr, bigMapValue;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _a = schema.EncodeBigMapKey(keyToEncode), key = _a.key, type = _a.type;\n            return [4\n            /*yield*/\n            , this.context.rpc.packData({\n              data: key,\n              type: type\n            })];\n\n          case 1:\n            packed = _b.sent().packed;\n            encodedExpr = encodeExpr(packed);\n            return [4\n            /*yield*/\n            , this.context.rpc.getBigMapExpr(id.toString(), encodedExpr)];\n\n          case 2:\n            bigMapValue = _b.sent();\n            return [2\n            /*return*/\n            , schema.ExecuteOnBigMapValue(bigMapValue, smartContractAbstractionSemantic(this))];\n        }\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @description Originate a new contract according to the script in parameters. Will sign and inject an operation using the current context\r\n   *\r\n   * @returns An operation handle with the result from the rpc node\r\n   *\r\n   * @warn You cannot specify storage and init at the same time (use init to pass the raw michelson representation of storage)\r\n   *\r\n   * @param OriginationOperation Originate operation parameter\r\n   */\n\n\n  RpcContractProvider.prototype.originate = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      var estimate, publicKeyHash, operation, preparedOrigination, forgedOrigination, _a, hash, context, forgedBytes, opResponse;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.estimate(params, this.estimator.originate.bind(this.estimator))];\n\n          case 1:\n            estimate = _b.sent();\n            return [4\n            /*yield*/\n            , this.signer.publicKeyHash()];\n\n          case 2:\n            publicKeyHash = _b.sent();\n            return [4\n            /*yield*/\n            , createOriginationOperation(__assign(__assign({}, params), estimate))];\n\n          case 3:\n            operation = _b.sent();\n            return [4\n            /*yield*/\n            , this.prepareOperation({\n              operation: operation,\n              source: publicKeyHash\n            })];\n\n          case 4:\n            preparedOrigination = _b.sent();\n            return [4\n            /*yield*/\n            , this.forge(preparedOrigination)];\n\n          case 5:\n            forgedOrigination = _b.sent();\n            return [4\n            /*yield*/\n            , this.signAndInject(forgedOrigination)];\n\n          case 6:\n            _a = _b.sent(), hash = _a.hash, context = _a.context, forgedBytes = _a.forgedBytes, opResponse = _a.opResponse;\n            return [2\n            /*return*/\n            , new OriginationOperation(hash, operation, forgedBytes, opResponse, context, this)];\n        }\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @description Set the delegate for a contract. Will sign and inject an operation using the current context\r\n   *\r\n   * @returns An operation handle with the result from the rpc node\r\n   *\r\n   * @param SetDelegate operation parameter\r\n   */\n\n\n  RpcContractProvider.prototype.setDelegate = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      var estimate, operation, sourceOrDefault, _a, opBytes, _b, hash, context, forgedBytes, opResponse;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            // Since babylon delegation source cannot smart contract\n            if (/kt1/i.test(params.source)) {\n              throw new InvalidDelegationSource(params.source);\n            }\n\n            return [4\n            /*yield*/\n            , this.estimate(params, this.estimator.setDelegate.bind(this.estimator))];\n\n          case 1:\n            estimate = _c.sent();\n            return [4\n            /*yield*/\n            , createSetDelegateOperation(__assign(__assign({}, params), estimate))];\n\n          case 2:\n            operation = _c.sent();\n            _a = params.source;\n            if (_a) return [3\n            /*break*/\n            , 4];\n            return [4\n            /*yield*/\n            , this.signer.publicKeyHash()];\n\n          case 3:\n            _a = _c.sent();\n            _c.label = 4;\n\n          case 4:\n            sourceOrDefault = _a;\n            return [4\n            /*yield*/\n            , this.prepareAndForge({\n              operation: operation,\n              source: sourceOrDefault\n            })];\n\n          case 5:\n            opBytes = _c.sent();\n            return [4\n            /*yield*/\n            , this.signAndInject(opBytes)];\n\n          case 6:\n            _b = _c.sent(), hash = _b.hash, context = _b.context, forgedBytes = _b.forgedBytes, opResponse = _b.opResponse;\n            return [2\n            /*return*/\n            , new DelegateOperation(hash, operation, sourceOrDefault, forgedBytes, opResponse, context)];\n        }\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @description Register the current address as delegate. Will sign and inject an operation using the current context\r\n   *\r\n   * @returns An operation handle with the result from the rpc node\r\n   *\r\n   * @param RegisterDelegate operation parameter\r\n   */\n\n\n  RpcContractProvider.prototype.registerDelegate = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      var estimate, source, operation, opBytes, _a, hash, context, forgedBytes, opResponse;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.estimate(params, this.estimator.registerDelegate.bind(this.estimator))];\n\n          case 1:\n            estimate = _b.sent();\n            return [4\n            /*yield*/\n            , this.signer.publicKeyHash()];\n\n          case 2:\n            source = _b.sent();\n            return [4\n            /*yield*/\n            , createRegisterDelegateOperation(__assign(__assign({}, params), estimate), source)];\n\n          case 3:\n            operation = _b.sent();\n            return [4\n            /*yield*/\n            , this.prepareAndForge({\n              operation: operation\n            })];\n\n          case 4:\n            opBytes = _b.sent();\n            return [4\n            /*yield*/\n            , this.signAndInject(opBytes)];\n\n          case 5:\n            _a = _b.sent(), hash = _a.hash, context = _a.context, forgedBytes = _a.forgedBytes, opResponse = _a.opResponse;\n            return [2\n            /*return*/\n            , new DelegateOperation(hash, operation, source, forgedBytes, opResponse, context)];\n        }\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @description Transfer tz from current address to a specific address. Will sign and inject an operation using the current context\r\n   *\r\n   * @returns An operation handle with the result from the rpc node\r\n   *\r\n   * @param Transfer operation parameter\r\n   */\n\n\n  RpcContractProvider.prototype.transfer = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      var estimate, operation, source, _a, opBytes, _b, hash, context, forgedBytes, opResponse;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.estimate(params, this.estimator.transfer.bind(this.estimator))];\n\n          case 1:\n            estimate = _c.sent();\n            return [4\n            /*yield*/\n            , createTransferOperation(__assign(__assign({}, params), estimate))];\n\n          case 2:\n            operation = _c.sent();\n            _a = params.source;\n            if (_a) return [3\n            /*break*/\n            , 4];\n            return [4\n            /*yield*/\n            , this.signer.publicKeyHash()];\n\n          case 3:\n            _a = _c.sent();\n            _c.label = 4;\n\n          case 4:\n            source = _a;\n            return [4\n            /*yield*/\n            , this.prepareAndForge({\n              operation: operation,\n              source: params.source\n            })];\n\n          case 5:\n            opBytes = _c.sent();\n            return [4\n            /*yield*/\n            , this.signAndInject(opBytes)];\n\n          case 6:\n            _b = _c.sent(), hash = _b.hash, context = _b.context, forgedBytes = _b.forgedBytes, opResponse = _b.opResponse;\n            return [2\n            /*return*/\n            , new TransactionOperation(hash, operation, source, forgedBytes, opResponse, context)];\n        }\n      });\n    });\n  };\n\n  RpcContractProvider.prototype.at = function (address) {\n    return __awaiter(this, void 0, void 0, function () {\n      var script, entrypoints;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.rpc.getScript(address)];\n\n          case 1:\n            script = _a.sent();\n            return [4\n            /*yield*/\n            , this.rpc.getEntrypoints(address)];\n\n          case 2:\n            entrypoints = _a.sent();\n            return [2\n            /*return*/\n            , new Contract(address, script, this, entrypoints)];\n        }\n      });\n    });\n  };\n\n  return RpcContractProvider;\n}(OperationEmitter);\n\nvar MINIMAL_FEE_MUTEZ = 100;\nvar MINIMAL_FEE_PER_BYTE_MUTEZ = 1;\nvar MINIMAL_FEE_PER_STORAGE_BYTE_MUTEZ = 1000;\nvar MINIMAL_FEE_PER_GAS_MUTEZ = 0.1;\nvar GAS_BUFFER = 100;\n\nvar Estimate =\n/** @class */\nfunction () {\n  function Estimate(_gasLimit, _storageLimit, opSize,\n  /**\r\n   * @description Base fee in mutez (1 mutez = 1e106 tez)\r\n   */\n  baseFeeMutez) {\n    if (baseFeeMutez === void 0) {\n      baseFeeMutez = MINIMAL_FEE_MUTEZ;\n    }\n\n    this._gasLimit = _gasLimit;\n    this._storageLimit = _storageLimit;\n    this.opSize = opSize;\n    this.baseFeeMutez = baseFeeMutez;\n  }\n\n  Object.defineProperty(Estimate.prototype, \"burnFeeMutez\", {\n    /**\r\n     * @description Burn fee in mutez\r\n     */\n    get: function () {\n      return this.roundUp(Number(this.storageLimit) * MINIMAL_FEE_PER_STORAGE_BYTE_MUTEZ);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Estimate.prototype, \"storageLimit\", {\n    /**\r\n     * @description Get the estimated storage limit\r\n     */\n    get: function () {\n      var limit = Math.max(Number(this._storageLimit), 0);\n      return limit > 0 ? limit : 0;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Estimate.prototype, \"gasLimit\", {\n    /**\r\n     * @description Suggested gasLimit for operation\r\n     */\n    get: function () {\n      return Number(this._gasLimit) + GAS_BUFFER;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Estimate.prototype, \"operationFeeMutez\", {\n    get: function () {\n      return this.gasLimit * MINIMAL_FEE_PER_GAS_MUTEZ + Number(this.opSize) * MINIMAL_FEE_PER_BYTE_MUTEZ;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Estimate.prototype.roundUp = function (nanotez) {\n    return Math.ceil(Number(nanotez));\n  };\n\n  Object.defineProperty(Estimate.prototype, \"minimalFeeMutez\", {\n    /**\r\n     * @description Minimum fees for operation according to baker defaults\r\n     */\n    get: function () {\n      return this.roundUp(MINIMAL_FEE_MUTEZ + this.operationFeeMutez);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Estimate.prototype, \"suggestedFeeMutez\", {\n    /**\r\n     * @description Suggested fee for operation (minimal fees plus a small buffer)\r\n     */\n    get: function () {\n      return this.roundUp(this.operationFeeMutez + MINIMAL_FEE_MUTEZ * 2);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Estimate.prototype, \"usingBaseFeeMutez\", {\n    /**\r\n     * @description Fees according to your specified base fee will ensure that at least minimum fees are used\r\n     */\n    get: function () {\n      return Math.max(Number(this.baseFeeMutez), MINIMAL_FEE_MUTEZ) + this.roundUp(this.operationFeeMutez);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Estimate.prototype, \"totalCost\", {\n    get: function () {\n      return this.minimalFeeMutez + this.burnFeeMutez;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return Estimate;\n}(); // RPC require a signature but do not verify it\n\n\nvar SIGNATURE_STUB = 'edsigtkpiSSschcaCt9pUVrpNPf7TTcgvgDEDD6NCEHMy8NNQJCGnMfLZzYoQj74yLjo9wx6MPVV29CvVzgi7qEcEUok3k7AuMg';\n\nvar RPCEstimateProvider =\n/** @class */\nfunction (_super) {\n  __extends(RPCEstimateProvider, _super);\n\n  function RPCEstimateProvider() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.ALLOCATION_STORAGE = 257;\n    _this.ORIGINATION_STORAGE = 257;\n    return _this;\n  } // Maximum values defined by the protocol\n\n\n  RPCEstimateProvider.prototype.getAccountLimits = function (pkh) {\n    return __awaiter(this, void 0, void 0, function () {\n      var balance, _a, hard_gas_limit_per_operation, hard_storage_limit_per_operation, cost_per_byte;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.rpc.getBalance(pkh)];\n\n          case 1:\n            balance = _b.sent();\n            return [4\n            /*yield*/\n            , this.rpc.getConstants()];\n\n          case 2:\n            _a = _b.sent(), hard_gas_limit_per_operation = _a.hard_gas_limit_per_operation, hard_storage_limit_per_operation = _a.hard_storage_limit_per_operation, cost_per_byte = _a.cost_per_byte;\n            return [2\n            /*return*/\n            , {\n              fee: 0,\n              gasLimit: hard_gas_limit_per_operation.toNumber(),\n              storageLimit: Math.floor(BigNumber.min(balance.dividedBy(cost_per_byte), hard_storage_limit_per_operation).toNumber())\n            }];\n        }\n      });\n    });\n  };\n\n  RPCEstimateProvider.prototype.createEstimateFromOperationContent = function (content, size) {\n    var _this = this;\n\n    var operationResults = flattenOperationResult({\n      contents: [content]\n    });\n    var totalGas = 0;\n    var totalStorage = 0;\n    operationResults.forEach(function (result) {\n      totalStorage += 'originated_contracts' in result && typeof result.originated_contracts !== 'undefined' ? result.originated_contracts.length * _this.ORIGINATION_STORAGE : 0;\n      totalStorage += 'allocated_destination_contract' in result ? _this.ALLOCATION_STORAGE : 0;\n      totalGas += Number(result.consumed_gas) || 0;\n      totalStorage += 'paid_storage_size_diff' in result ? Number(result.paid_storage_size_diff) || 0 : 0;\n    });\n\n    if (isOpWithFee(content)) {\n      return new Estimate(totalGas || 0, Number(totalStorage || 0), size);\n    } else {\n      return new Estimate(0, 0, size, 0);\n    }\n  };\n\n  RPCEstimateProvider.prototype.createEstimate = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, opbytes, _b, branch, contents, operation, _c, opResponse, errors;\n\n      var _this = this;\n\n      return __generator(this, function (_d) {\n        switch (_d.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.prepareAndForge(params)];\n\n          case 1:\n            _a = _d.sent(), opbytes = _a.opbytes, _b = _a.opOb, branch = _b.branch, contents = _b.contents;\n            _c = {\n              operation: {\n                branch: branch,\n                contents: contents,\n                signature: SIGNATURE_STUB\n              }\n            };\n            return [4\n            /*yield*/\n            , this.rpc.getChainId()];\n\n          case 2:\n            operation = (_c.chain_id = _d.sent(), _c);\n            return [4\n            /*yield*/\n            , this.simulate(operation)];\n\n          case 3:\n            opResponse = _d.sent().opResponse;\n            errors = __spread(flattenErrors(opResponse, 'backtracked'), flattenErrors(opResponse)); // Fail early in case of errors\n\n            if (errors.length) {\n              throw new TezosOperationError(errors);\n            }\n\n            while (opResponse.contents.length !== (Array.isArray(params.operation) ? params.operation.length : 1)) {\n              opResponse.contents.shift();\n            }\n\n            return [2\n            /*return*/\n            , opResponse.contents.map(function (x) {\n              return _this.createEstimateFromOperationContent(x, opbytes.length / 2 / opResponse.contents.length);\n            })];\n        }\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @description Estimate gasLimit, storageLimit and fees for an origination operation\r\n   *\r\n   * @returns An estimation of gasLimit, storageLimit and fees for the operation\r\n   *\r\n   * @param OriginationOperation Originate operation parameter\r\n   */\n\n\n  RPCEstimateProvider.prototype.originate = function (_a) {\n    var fee = _a.fee,\n        storageLimit = _a.storageLimit,\n        gasLimit = _a.gasLimit,\n        rest = __rest(_a, [\"fee\", \"storageLimit\", \"gasLimit\"]);\n\n    return __awaiter(this, void 0, void 0, function () {\n      var pkh, DEFAULT_PARAMS, op;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.signer.publicKeyHash()];\n\n          case 1:\n            pkh = _b.sent();\n            return [4\n            /*yield*/\n            , this.getAccountLimits(pkh)];\n\n          case 2:\n            DEFAULT_PARAMS = _b.sent();\n            return [4\n            /*yield*/\n            , createOriginationOperation(__assign(__assign({}, rest), DEFAULT_PARAMS))];\n\n          case 3:\n            op = _b.sent();\n            return [4\n            /*yield*/\n            , this.createEstimate({\n              operation: op,\n              source: pkh\n            })];\n\n          case 4:\n            return [2\n            /*return*/\n            , _b.sent()[0]];\n        }\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @description Estimate gasLimit, storageLimit and fees for an transfer operation\r\n   *\r\n   * @returns An estimation of gasLimit, storageLimit and fees for the operation\r\n   *\r\n   * @param TransferOperation Originate operation parameter\r\n   */\n\n\n  RPCEstimateProvider.prototype.transfer = function (_a) {\n    var fee = _a.fee,\n        storageLimit = _a.storageLimit,\n        gasLimit = _a.gasLimit,\n        rest = __rest(_a, [\"fee\", \"storageLimit\", \"gasLimit\"]);\n\n    return __awaiter(this, void 0, void 0, function () {\n      var pkh, DEFAULT_PARAMS, op;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.signer.publicKeyHash()];\n\n          case 1:\n            pkh = _b.sent();\n            return [4\n            /*yield*/\n            , this.getAccountLimits(pkh)];\n\n          case 2:\n            DEFAULT_PARAMS = _b.sent();\n            return [4\n            /*yield*/\n            , createTransferOperation(__assign(__assign({}, rest), DEFAULT_PARAMS))];\n\n          case 3:\n            op = _b.sent();\n            return [4\n            /*yield*/\n            , this.createEstimate({\n              operation: op,\n              source: pkh\n            })];\n\n          case 4:\n            return [2\n            /*return*/\n            , _b.sent()[0]];\n        }\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @description Estimate gasLimit, storageLimit and fees for a delegate operation\r\n   *\r\n   * @returns An estimation of gasLimit, storageLimit and fees for the operation\r\n   *\r\n   * @param Estimate\r\n   */\n\n\n  RPCEstimateProvider.prototype.setDelegate = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      var sourceOrDefault, _a, DEFAULT_PARAMS, op;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _a = params.source;\n            if (_a) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this.signer.publicKeyHash()];\n\n          case 1:\n            _a = _b.sent();\n            _b.label = 2;\n\n          case 2:\n            sourceOrDefault = _a;\n            return [4\n            /*yield*/\n            , this.getAccountLimits(sourceOrDefault)];\n\n          case 3:\n            DEFAULT_PARAMS = _b.sent();\n            return [4\n            /*yield*/\n            , createSetDelegateOperation(__assign(__assign({}, params), DEFAULT_PARAMS))];\n\n          case 4:\n            op = _b.sent();\n            return [4\n            /*yield*/\n            , this.createEstimate({\n              operation: op,\n              source: sourceOrDefault\n            })];\n\n          case 5:\n            return [2\n            /*return*/\n            , _b.sent()[0]];\n        }\n      });\n    });\n  };\n\n  RPCEstimateProvider.prototype.batch = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      var operations, DEFAULT_PARAMS, _a, params_1, params_1_1, param, _b, _c, _d, _e, _f, _g, _h, e_1_1;\n\n      var e_1, _j;\n\n      return __generator(this, function (_k) {\n        switch (_k.label) {\n          case 0:\n            operations = [];\n            _a = this.getAccountLimits;\n            return [4\n            /*yield*/\n            , this.signer.publicKeyHash()];\n\n          case 1:\n            return [4\n            /*yield*/\n            , _a.apply(this, [_k.sent()])];\n\n          case 2:\n            DEFAULT_PARAMS = _k.sent();\n            _k.label = 3;\n\n          case 3:\n            _k.trys.push([3, 15, 16, 17]);\n\n            params_1 = __values(params), params_1_1 = params_1.next();\n            _k.label = 4;\n\n          case 4:\n            if (!!params_1_1.done) return [3\n            /*break*/\n            , 14];\n            param = params_1_1.value;\n            _b = param.kind;\n\n            switch (_b) {\n              case OpKind.TRANSACTION:\n                return [3\n                /*break*/\n                , 5];\n\n              case OpKind.ORIGINATION:\n                return [3\n                /*break*/\n                , 7];\n\n              case OpKind.DELEGATION:\n                return [3\n                /*break*/\n                , 9];\n\n              case OpKind.ACTIVATION:\n                return [3\n                /*break*/\n                , 11];\n            }\n\n            return [3\n            /*break*/\n            , 12];\n\n          case 5:\n            _d = (_c = operations).push;\n            return [4\n            /*yield*/\n            , createTransferOperation(__assign(__assign({}, param), DEFAULT_PARAMS))];\n\n          case 6:\n            _d.apply(_c, [_k.sent()]);\n\n            return [3\n            /*break*/\n            , 13];\n\n          case 7:\n            _f = (_e = operations).push;\n            return [4\n            /*yield*/\n            , createOriginationOperation(__assign(__assign({}, param), DEFAULT_PARAMS))];\n\n          case 8:\n            _f.apply(_e, [_k.sent()]);\n\n            return [3\n            /*break*/\n            , 13];\n\n          case 9:\n            _h = (_g = operations).push;\n            return [4\n            /*yield*/\n            , createSetDelegateOperation(__assign(__assign({}, param), DEFAULT_PARAMS))];\n\n          case 10:\n            _h.apply(_g, [_k.sent()]);\n\n            return [3\n            /*break*/\n            , 13];\n\n          case 11:\n            operations.push(__assign(__assign({}, param), DEFAULT_PARAMS));\n            return [3\n            /*break*/\n            , 13];\n\n          case 12:\n            throw new Error(\"Unsupported operation kind: \" + param.kind);\n\n          case 13:\n            params_1_1 = params_1.next();\n            return [3\n            /*break*/\n            , 4];\n\n          case 14:\n            return [3\n            /*break*/\n            , 17];\n\n          case 15:\n            e_1_1 = _k.sent();\n            e_1 = {\n              error: e_1_1\n            };\n            return [3\n            /*break*/\n            , 17];\n\n          case 16:\n            try {\n              if (params_1_1 && !params_1_1.done && (_j = params_1.return)) _j.call(params_1);\n            } finally {\n              if (e_1) throw e_1.error;\n            }\n\n            return [7\n            /*endfinally*/\n            ];\n\n          case 17:\n            return [2\n            /*return*/\n            , this.createEstimate({\n              operation: operations\n            })];\n        }\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @description Estimate gasLimit, storageLimit and fees for a delegate operation\r\n   *\r\n   * @returns An estimation of gasLimit, storageLimit and fees for the operation\r\n   *\r\n   * @param Estimate\r\n   */\n\n\n  RPCEstimateProvider.prototype.registerDelegate = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      var DEFAULT_PARAMS, _a, op, _b, _c, _d, _e;\n\n      return __generator(this, function (_f) {\n        switch (_f.label) {\n          case 0:\n            _a = this.getAccountLimits;\n            return [4\n            /*yield*/\n            , this.signer.publicKeyHash()];\n\n          case 1:\n            return [4\n            /*yield*/\n            , _a.apply(this, [_f.sent()])];\n\n          case 2:\n            DEFAULT_PARAMS = _f.sent();\n            _b = createRegisterDelegateOperation;\n            _c = [__assign(__assign({}, params), DEFAULT_PARAMS)];\n            return [4\n            /*yield*/\n            , this.signer.publicKeyHash()];\n\n          case 3:\n            return [4\n            /*yield*/\n            , _b.apply(void 0, _c.concat([_f.sent()]))];\n\n          case 4:\n            op = _f.sent();\n            _d = this.createEstimate;\n            _e = {\n              operation: op\n            };\n            return [4\n            /*yield*/\n            , this.signer.publicKeyHash()];\n\n          case 5:\n            return [4\n            /*yield*/\n            , _d.apply(this, [(_e.source = _f.sent(), _e)])];\n\n          case 6:\n            return [2\n            /*return*/\n            , _f.sent()[0]];\n        }\n      });\n    });\n  };\n\n  return RPCEstimateProvider;\n}(OperationEmitter);\n\nvar opHashFilter = function (op, filter) {\n  return op.hash === filter.opHash;\n};\n\nvar sourceFilter = function (x, filter) {\n  switch (x.kind) {\n    case 'endorsement':\n      return 'metadata' in x && x.metadata.delegate === filter.source;\n\n    case 'activate_account':\n      return 'metadata' in x && x.pkh === filter.source;\n\n    default:\n      return 'source' in x && x.source === filter.source;\n  }\n};\n\nvar kindFilter = function (x, filter) {\n  return 'kind' in x && x.kind === filter.kind;\n};\n\nvar destinationFilter = function (x, filter) {\n  switch (x.kind) {\n    case 'delegation':\n      return x.delegate === filter.destination;\n\n    case 'origination':\n      if ('metadata' in x && 'operation_result' in x.metadata && 'originated_contracts' in x.metadata.operation_result && Array.isArray(x.metadata.operation_result.originated_contracts)) {\n        return x.metadata.operation_result.originated_contracts.some(function (contract) {\n          return contract === filter.destination;\n        });\n      }\n\n      break;\n\n    case 'transaction':\n      return x.destination === filter.destination;\n\n    default:\n      return false;\n  }\n};\n\nvar evaluateOpFilter = function (op, filter) {\n  if ('opHash' in filter) {\n    return opHashFilter(op, filter);\n  } else if ('source' in filter) {\n    return sourceFilter(op, filter);\n  } else if ('kind' in filter) {\n    return kindFilter(op, filter);\n  } else if ('destination' in filter) {\n    return destinationFilter(op, filter);\n  }\n\n  return false;\n};\n\nvar evaluateExpression = function (op, exp) {\n  if (Array.isArray(exp.and)) {\n    return exp.and.every(function (x) {\n      return evaluateFilter(op, x);\n    });\n  } else if (Array.isArray(exp.or)) {\n    return exp.or.some(function (x) {\n      return evaluateFilter(op, x);\n    });\n  } else {\n    throw new Error('Filter expression must contains either and/or property');\n  }\n};\n\nvar evaluateFilter = function (op, filter) {\n  var filters = [];\n\n  if (!Array.isArray(filter)) {\n    filters.push(filter);\n  } else {\n    filters.push.apply(filters, __spread(filter));\n  }\n\n  return filters.every(function (filterOrExp) {\n    if ('and' in filterOrExp || 'or' in filterOrExp) {\n      return evaluateExpression(op, filterOrExp);\n    } else {\n      return evaluateOpFilter(op, filterOrExp);\n    }\n  });\n};\n\nvar ObservableSubscription =\n/** @class */\nfunction () {\n  function ObservableSubscription(obs) {\n    var _this = this;\n\n    this.errorListeners = [];\n    this.messageListeners = [];\n    this.closeListeners = [];\n    this.completed$ = new Subject();\n    obs.pipe(takeUntil(this.completed$)).subscribe(function (data) {\n      _this.call(_this.messageListeners, data);\n    }, function (error) {\n      _this.call(_this.errorListeners, error);\n    }, function () {\n      _this.call(_this.closeListeners);\n    });\n  }\n\n  ObservableSubscription.prototype.call = function (listeners, value) {\n    var e_1, _a;\n\n    try {\n      for (var listeners_1 = __values(listeners), listeners_1_1 = listeners_1.next(); !listeners_1_1.done; listeners_1_1 = listeners_1.next()) {\n        var l = listeners_1_1.value;\n\n        try {\n          l(value);\n        } catch (ex) {\n          console.error(ex);\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (listeners_1_1 && !listeners_1_1.done && (_a = listeners_1.return)) _a.call(listeners_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  };\n\n  ObservableSubscription.prototype.remove = function (listeners, value) {\n    var idx = listeners.indexOf(value);\n\n    if (idx !== -1) {\n      listeners.splice(idx, 1);\n    }\n  };\n\n  ObservableSubscription.prototype.on = function (type, cb) {\n    switch (type) {\n      case 'data':\n        this.messageListeners.push(cb);\n        break;\n\n      case 'error':\n        this.errorListeners.push(cb);\n        break;\n\n      case 'close':\n        this.closeListeners.push(cb);\n        break;\n\n      default:\n        throw new Error(\"Trying to register on an unsupported event: \" + type);\n    }\n  };\n\n  ObservableSubscription.prototype.off = function (type, cb) {\n    switch (type) {\n      case 'data':\n        this.remove(this.messageListeners, cb);\n        break;\n\n      case 'error':\n        this.remove(this.errorListeners, cb);\n        break;\n\n      case 'close':\n        this.remove(this.closeListeners, cb);\n        break;\n\n      default:\n        throw new Error(\"Trying to unregister on an unsupported event: \" + type);\n    }\n  };\n\n  ObservableSubscription.prototype.close = function () {\n    this.completed$.next();\n  };\n\n  return ObservableSubscription;\n}();\n\nvar getLastBlock = function (context) {\n  return from(context.rpc.getBlock()).pipe(first());\n};\n\nvar applyFilter = function (filter) {\n  return concatMap(function (block) {\n    return new Observable(function (sub) {\n      var e_1, _a, e_2, _b, e_3, _c;\n\n      try {\n        for (var _d = __values(block.operations), _e = _d.next(); !_e.done; _e = _d.next()) {\n          var ops = _e.value;\n\n          try {\n            for (var ops_1 = (e_2 = void 0, __values(ops)), ops_1_1 = ops_1.next(); !ops_1_1.done; ops_1_1 = ops_1.next()) {\n              var op = ops_1_1.value;\n\n              try {\n                for (var _f = (e_3 = void 0, __values(op.contents)), _g = _f.next(); !_g.done; _g = _f.next()) {\n                  var content = _g.value;\n\n                  if (evaluateFilter(__assign({\n                    hash: op.hash\n                  }, content), filter)) {\n                    sub.next(__assign({\n                      hash: op.hash\n                    }, content));\n                  }\n                }\n              } catch (e_3_1) {\n                e_3 = {\n                  error: e_3_1\n                };\n              } finally {\n                try {\n                  if (_g && !_g.done && (_c = _f.return)) _c.call(_f);\n                } finally {\n                  if (e_3) throw e_3.error;\n                }\n              }\n            }\n          } catch (e_2_1) {\n            e_2 = {\n              error: e_2_1\n            };\n          } finally {\n            try {\n              if (ops_1_1 && !ops_1_1.done && (_b = ops_1.return)) _b.call(ops_1);\n            } finally {\n              if (e_2) throw e_2.error;\n            }\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_e && !_e.done && (_a = _d.return)) _a.call(_d);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      sub.complete();\n    });\n  });\n};\n\nvar PollingSubscribeProvider =\n/** @class */\nfunction () {\n  function PollingSubscribeProvider(context, POLL_INTERVAL) {\n    var _this = this;\n\n    if (POLL_INTERVAL === void 0) {\n      POLL_INTERVAL = 20000;\n    }\n\n    this.context = context;\n    this.POLL_INTERVAL = POLL_INTERVAL;\n    this.newBlock$ = timer(0, this.POLL_INTERVAL).pipe(map(function () {\n      return _this.context;\n    }), switchMap(getLastBlock), distinctUntilKeyChanged('hash'), publishReplay(), refCount());\n  }\n\n  PollingSubscribeProvider.prototype.subscribe = function (_filter) {\n    return new ObservableSubscription(this.newBlock$.pipe(pluck('hash')));\n  };\n\n  PollingSubscribeProvider.prototype.subscribeOperation = function (filter) {\n    return new ObservableSubscription(this.newBlock$.pipe(applyFilter(filter)));\n  };\n\n  return PollingSubscribeProvider;\n}();\n\nvar RpcTzProvider =\n/** @class */\nfunction (_super) {\n  __extends(RpcTzProvider, _super);\n\n  function RpcTzProvider(context) {\n    return _super.call(this, context) || this;\n  }\n\n  RpcTzProvider.prototype.getBalance = function (address) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.rpc.getBalance(address)];\n      });\n    });\n  };\n\n  RpcTzProvider.prototype.getDelegate = function (address) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.rpc.getDelegate(address)];\n      });\n    });\n  };\n\n  RpcTzProvider.prototype.activate = function (pkh, secret) {\n    return __awaiter(this, void 0, void 0, function () {\n      var operation, forgedBytes, bytes, _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            operation = {\n              kind: OpKind.ACTIVATION,\n              pkh: pkh,\n              secret: secret\n            };\n            return [4\n            /*yield*/\n            , this.prepareAndForge({\n              operation: [operation],\n              source: pkh\n            })];\n\n          case 1:\n            forgedBytes = _b.sent();\n            bytes = forgedBytes.opbytes + \"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\";\n            _a = Operation.bind;\n            return [4\n            /*yield*/\n            , this.rpc.injectOperation(bytes)];\n\n          case 2:\n            return [2\n            /*return*/\n            , new (_a.apply(Operation, [void 0, _b.sent(), __assign(__assign({}, forgedBytes), {\n              opbytes: bytes\n            }), [], this.context.clone()]))()];\n        }\n      });\n    });\n  };\n\n  return RpcTzProvider;\n}(OperationEmitter);\n\nvar BatchOperation =\n/** @class */\nfunction (_super) {\n  __extends(BatchOperation, _super);\n\n  function BatchOperation(hash, params, source, raw, results, context) {\n    var _this = _super.call(this, hash, raw, results, context) || this;\n\n    _this.params = params;\n    _this.source = source;\n    return _this;\n  }\n\n  BatchOperation.prototype.sumProp = function (arr, prop) {\n    return arr.reduce(function (prev, current) {\n      return prop in current ? Number(current[prop]) + prev : prev;\n    }, 0);\n  };\n\n  Object.defineProperty(BatchOperation.prototype, \"fee\", {\n    get: function () {\n      return this.sumProp(this.params, 'fee');\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(BatchOperation.prototype, \"gasLimit\", {\n    get: function () {\n      return this.sumProp(this.params, 'gas_limit');\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(BatchOperation.prototype, \"storageLimit\", {\n    get: function () {\n      return this.sumProp(this.params, 'storage_limit');\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(BatchOperation.prototype, \"consumedGas\", {\n    get: function () {\n      return String(this.sumProp(flattenOperationResult({\n        contents: this.results\n      }), 'consumed_gas'));\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(BatchOperation.prototype, \"storageDiff\", {\n    get: function () {\n      return String(this.sumProp(flattenOperationResult({\n        contents: this.results\n      }), 'paid_storage_size_diff'));\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(BatchOperation.prototype, \"errors\", {\n    get: function () {\n      return flattenErrors({\n        contents: this.results\n      });\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return BatchOperation;\n}(Operation);\n\nvar OperationBatch =\n/** @class */\nfunction (_super) {\n  __extends(OperationBatch, _super);\n\n  function OperationBatch(context, estimator) {\n    var _this = _super.call(this, context) || this;\n\n    _this.estimator = estimator;\n    _this.operations = [];\n    return _this;\n  }\n  /**\r\n   *\r\n   * @description Add a transaction operation to the batch\r\n   *\r\n   * @param params Transfer operation parameter\r\n   */\n\n\n  OperationBatch.prototype.withTransfer = function (params) {\n    this.operations.push(__assign({\n      kind: OpKind.TRANSACTION\n    }, params));\n    return this;\n  };\n  /**\r\n   *\r\n   * @description Add a transaction operation to the batch\r\n   *\r\n   * @param params Transfer operation parameter\r\n   */\n\n\n  OperationBatch.prototype.withContractCall = function (params) {\n    return this.withTransfer(params.toTransferParams());\n  };\n  /**\r\n   *\r\n   * @description Add a delegation operation to the batch\r\n   *\r\n   * @param params Delegation operation parameter\r\n   */\n\n\n  OperationBatch.prototype.withDelegation = function (params) {\n    this.operations.push(__assign({\n      kind: OpKind.DELEGATION\n    }, params));\n    return this;\n  };\n  /**\r\n   *\r\n   * @description Add an activation operation to the batch\r\n   *\r\n   * @param params Activation operation parameter\r\n   */\n\n\n  OperationBatch.prototype.withActivation = function (_a) {\n    var pkh = _a.pkh,\n        secret = _a.secret;\n    this.operations.push({\n      kind: OpKind.ACTIVATION,\n      pkh: pkh,\n      secret: secret\n    });\n    return this;\n  };\n  /**\r\n   *\r\n   * @description Add an origination operation to the batch\r\n   *\r\n   * @param params Origination operation parameter\r\n   */\n\n\n  OperationBatch.prototype.withOrigination = function (params) {\n    this.operations.push(__assign({\n      kind: OpKind.ORIGINATION\n    }, params));\n    return this;\n  };\n\n  OperationBatch.prototype.getRPCOp = function (param) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (param.kind) {\n          case OpKind.TRANSACTION:\n            return [2\n            /*return*/\n            , createTransferOperation(__assign({}, param))];\n\n          case OpKind.ORIGINATION:\n            return [2\n            /*return*/\n            , createOriginationOperation(__assign({}, param))];\n\n          case OpKind.DELEGATION:\n            return [2\n            /*return*/\n            , createSetDelegateOperation(__assign({}, param))];\n\n          case OpKind.ACTIVATION:\n            return [2\n            /*return*/\n            , __assign({}, param)];\n\n          default:\n            throw new Error(\"Unsupported operation kind: \" + param.kind);\n        }\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @description Add a group operation to the batch. Operation will be applied in the order they are in the params array\r\n   *\r\n   * @param params Operations parameter\r\n   */\n\n\n  OperationBatch.prototype.with = function (params) {\n    var e_1, _a;\n\n    try {\n      for (var params_1 = __values(params), params_1_1 = params_1.next(); !params_1_1.done; params_1_1 = params_1.next()) {\n        var param = params_1_1.value;\n\n        switch (param.kind) {\n          case OpKind.TRANSACTION:\n            this.withTransfer(param);\n            break;\n\n          case OpKind.ORIGINATION:\n            this.withOrigination(param);\n            break;\n\n          case OpKind.DELEGATION:\n            this.withDelegation(param);\n            break;\n\n          case OpKind.ACTIVATION:\n            this.withActivation(param);\n            break;\n\n          default:\n            throw new Error(\"Unsupported operation kind: \" + param.kind);\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (params_1_1 && !params_1_1.done && (_a = params_1.return)) _a.call(params_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    return this;\n  };\n  /**\r\n   *\r\n   * @description Forge and Inject the operation batch\r\n   *\r\n   * @param params Optionally specify the source of the operation\r\n   */\n\n\n  OperationBatch.prototype.send = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      var estimates, ops, i, _a, _b, op, estimated, _c, _d, e_2_1, source, _e, opBytes, _f, hash, context, forgedBytes, opResponse;\n\n      var e_2, _g;\n\n      var _this = this;\n\n      return __generator(this, function (_h) {\n        switch (_h.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.estimator.batch(this.operations)];\n\n          case 1:\n            estimates = _h.sent();\n            ops = [];\n            i = 0;\n            _h.label = 2;\n\n          case 2:\n            _h.trys.push([2, 10, 11, 12]);\n\n            _a = __values(this.operations), _b = _a.next();\n            _h.label = 3;\n\n          case 3:\n            if (!!_b.done) return [3\n            /*break*/\n            , 9];\n            op = _b.value;\n            if (!isOpWithFee(op)) return [3\n            /*break*/\n            , 6];\n            return [4\n            /*yield*/\n            , this.estimate(op, function () {\n              return __awaiter(_this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                  return [2\n                  /*return*/\n                  , estimates[i]];\n                });\n              });\n            })];\n\n          case 4:\n            estimated = _h.sent();\n            _d = (_c = ops).push;\n            return [4\n            /*yield*/\n            , this.getRPCOp(__assign(__assign({}, op), estimated))];\n\n          case 5:\n            _d.apply(_c, [_h.sent()]);\n\n            return [3\n            /*break*/\n            , 7];\n\n          case 6:\n            ops.push(__assign({}, op));\n            _h.label = 7;\n\n          case 7:\n            i++;\n            _h.label = 8;\n\n          case 8:\n            _b = _a.next();\n            return [3\n            /*break*/\n            , 3];\n\n          case 9:\n            return [3\n            /*break*/\n            , 12];\n\n          case 10:\n            e_2_1 = _h.sent();\n            e_2 = {\n              error: e_2_1\n            };\n            return [3\n            /*break*/\n            , 12];\n\n          case 11:\n            try {\n              if (_b && !_b.done && (_g = _a.return)) _g.call(_a);\n            } finally {\n              if (e_2) throw e_2.error;\n            }\n\n            return [7\n            /*endfinally*/\n            ];\n\n          case 12:\n            _e = params && params.source;\n            if (_e) return [3\n            /*break*/\n            , 14];\n            return [4\n            /*yield*/\n            , this.signer.publicKeyHash()];\n\n          case 13:\n            _e = _h.sent();\n            _h.label = 14;\n\n          case 14:\n            source = _e;\n            return [4\n            /*yield*/\n            , this.prepareAndForge({\n              operation: ops,\n              source: source\n            })];\n\n          case 15:\n            opBytes = _h.sent();\n            return [4\n            /*yield*/\n            , this.signAndInject(opBytes)];\n\n          case 16:\n            _f = _h.sent(), hash = _f.hash, context = _f.context, forgedBytes = _f.forgedBytes, opResponse = _f.opResponse;\n            return [2\n            /*return*/\n            , new BatchOperation(hash, ops, source, forgedBytes, opResponse, context)];\n        }\n      });\n    });\n  };\n\n  return OperationBatch;\n}(OperationEmitter);\n\nvar RPCBatchProvider =\n/** @class */\nfunction () {\n  function RPCBatchProvider(context, estimator) {\n    this.context = context;\n    this.estimator = estimator;\n  }\n  /***\r\n   *\r\n   * @description Batch a group of operation together. Operations will be applied in the order in which they are added to the batch\r\n   *\r\n   * @param params List of operation to batch together\r\n   */\n\n\n  RPCBatchProvider.prototype.batch = function (params) {\n    var batch = new OperationBatch(this.context, this.estimator);\n\n    if (Array.isArray(params)) {\n      batch.with(params);\n    }\n\n    return batch;\n  };\n\n  return RPCBatchProvider;\n}();\n\nvar setDelegate = function (key) {\n  return [{\n    prim: 'DROP'\n  }, {\n    prim: 'NIL',\n    args: [{\n      prim: 'operation'\n    }]\n  }, {\n    prim: 'PUSH',\n    args: [{\n      prim: 'key_hash'\n    }, {\n      string: key\n    }]\n  }, {\n    prim: 'SOME'\n  }, {\n    prim: 'SET_DELEGATE'\n  }, {\n    prim: 'CONS'\n  }];\n};\n\nvar transferImplicit = function (key, mutez) {\n  return [{\n    prim: 'DROP'\n  }, {\n    prim: 'NIL',\n    args: [{\n      prim: 'operation'\n    }]\n  }, {\n    prim: 'PUSH',\n    args: [{\n      prim: 'key_hash'\n    }, {\n      string: key\n    }]\n  }, {\n    prim: 'IMPLICIT_ACCOUNT'\n  }, {\n    prim: 'PUSH',\n    args: [{\n      prim: 'mutez'\n    }, {\n      int: \"\" + mutez\n    }]\n  }, {\n    prim: 'UNIT'\n  }, {\n    prim: 'TRANSFER_TOKENS'\n  }, {\n    prim: 'CONS'\n  }];\n};\n\nvar removeDelegate = function () {\n  return [{\n    prim: 'DROP'\n  }, {\n    prim: 'NIL',\n    args: [{\n      prim: 'operation'\n    }]\n  }, {\n    prim: 'NONE',\n    args: [{\n      prim: 'key_hash'\n    }]\n  }, {\n    prim: 'SET_DELEGATE'\n  }, {\n    prim: 'CONS'\n  }];\n};\n\nvar transferToContract = function (key, amount) {\n  return [{\n    prim: 'DROP'\n  }, {\n    prim: 'NIL',\n    args: [{\n      prim: 'operation'\n    }]\n  }, {\n    prim: 'PUSH',\n    args: [{\n      prim: 'address'\n    }, {\n      string: key\n    }]\n  }, {\n    prim: 'CONTRACT',\n    args: [{\n      prim: 'unit'\n    }]\n  }, [{\n    prim: 'IF_NONE',\n    args: [[[{\n      prim: 'UNIT'\n    }, {\n      prim: 'FAILWITH'\n    }]], []]\n  }], {\n    prim: 'PUSH',\n    args: [{\n      prim: 'mutez'\n    }, {\n      int: \"\" + amount\n    }]\n  }, {\n    prim: 'UNIT'\n  }, {\n    prim: 'TRANSFER_TOKENS'\n  }, {\n    prim: 'CONS'\n  }];\n};\n\nvar MANAGER_LAMBDA = {\n  setDelegate: setDelegate,\n  removeDelegate: removeDelegate,\n  transferImplicit: transferImplicit,\n  transferToContract: transferToContract\n};\n\nvar ForgingMismatchError =\n/** @class */\nfunction () {\n  function ForgingMismatchError(results) {\n    this.results = results;\n    this.name = 'ForgingMismatchError';\n    this.message = 'Forging mismatch error';\n  }\n\n  return ForgingMismatchError;\n}();\n\nvar CompositeForger =\n/** @class */\nfunction () {\n  function CompositeForger(forgers) {\n    this.forgers = forgers;\n\n    if (forgers.length === 0) {\n      throw new Error('At least one forger must be specified');\n    }\n  }\n\n  CompositeForger.prototype.forge = function (_a) {\n    var branch = _a.branch,\n        contents = _a.contents;\n    return __awaiter(this, void 0, void 0, function () {\n      var results, lastResult, currentResult;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , Promise.all(this.forgers.map(function (forger) {\n              return forger.forge({\n                branch: branch,\n                contents: contents\n              });\n            }))];\n\n          case 1:\n            results = _b.sent();\n\n            if (results.length === 0) {\n              throw new Error('At least one forger must be specified');\n            }\n\n            lastResult = results.pop();\n\n            while (results.length) {\n              currentResult = results.pop();\n\n              if (currentResult !== lastResult) {\n                throw new ForgingMismatchError([lastResult, currentResult]);\n              }\n\n              lastResult = currentResult;\n            }\n\n            return [2\n            /*return*/\n            , lastResult];\n        }\n      });\n    });\n  };\n\n  return CompositeForger;\n}();\n/**\r\n * @description Facade class that surfaces all of the libraries capability and allow it's configuration\r\n */\n\n\nvar TezosToolkit =\n/** @class */\nfunction () {\n  function TezosToolkit() {\n    this._rpcClient = new RpcClient();\n    this._options = {};\n    this._context = new Context();\n    this._tz = new RpcTzProvider(this._context);\n    this._estimate = new RPCEstimateProvider(this._context);\n    this._contract = new RpcContractProvider(this._context, this._estimate);\n    this._batch = new RPCBatchProvider(this._context, this._estimate);\n    this.format = format;\n    this.batch = this._batch.batch.bind(this._batch);\n    this.setProvider({\n      rpc: this._rpcClient\n    });\n  }\n  /**\r\n   * @description Sets configuration on the Tezos Taquito instance. Allows user to choose which signer, rpc client, rpc url, forger and so forth\r\n   *\r\n   * @param options rpc url or rpcClient to use to interact with the Tezos network and  url to use to interact with the Tezos network\r\n   *\r\n   * @example Tezos.setProvider({signer: new InMemorySigner(edsk...)})\r\n   * @example Tezos.setProvider({config: {confirmationPollingTimeoutSecond: 300}})\r\n   *\r\n   */\n\n\n  TezosToolkit.prototype.setProvider = function (_a) {\n    var rpc = _a.rpc,\n        stream = _a.stream,\n        signer = _a.signer,\n        protocol = _a.protocol,\n        config = _a.config,\n        forger = _a.forger;\n    this.setRpcProvider(rpc);\n    this.setStreamProvider(stream);\n    this.setSignerProvider(signer);\n    this.setForgerProvider(forger);\n    this._context.proto = protocol;\n    this._context.config = config;\n  };\n\n  TezosToolkit.prototype.setSignerProvider = function (signer) {\n    if (!this._options.signer && typeof signer === 'undefined') {\n      this._context.signer = new NoopSigner();\n      this._options.signer = signer;\n    } else if (typeof signer !== 'undefined') {\n      this._context.signer = signer;\n      this._options.signer = signer;\n    }\n  };\n\n  TezosToolkit.prototype.setRpcProvider = function (rpc) {\n    if (typeof rpc === 'string') {\n      this._rpcClient = new RpcClient(rpc);\n    } else if (rpc instanceof RpcClient) {\n      this._rpcClient = rpc;\n    } else if (this._options.rpc === undefined) {\n      this._rpcClient = new RpcClient();\n    }\n\n    this._options.rpc = rpc;\n    this._context.rpc = this._rpcClient;\n  };\n\n  TezosToolkit.prototype.setForgerProvider = function (forger) {\n    var f = typeof forger === 'undefined' ? new RpcForger(this._context) : forger;\n    this._options.forger = f;\n    this._context.forger = f;\n  };\n\n  TezosToolkit.prototype.setStreamProvider = function (stream) {\n    if (typeof stream === 'string') {\n      this._stream = new PollingSubscribeProvider(new Context(new RpcClient(stream)));\n    } else if (typeof stream !== 'undefined') {\n      this._stream = stream;\n    } else if (this._options.stream === undefined) {\n      this._stream = new PollingSubscribeProvider(this._context);\n    }\n\n    this._options.stream = stream;\n  };\n\n  Object.defineProperty(TezosToolkit.prototype, \"tz\", {\n    /**\r\n     * @description Provide access to tezos account management\r\n     */\n    get: function () {\n      return this._tz;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TezosToolkit.prototype, \"contract\", {\n    /**\r\n     * @description Provide access to smart contract utilities\r\n     */\n    get: function () {\n      return this._contract;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TezosToolkit.prototype, \"estimate\", {\n    /**\r\n     * @description Provide access to operation estimation utilities\r\n     */\n    get: function () {\n      return this._estimate;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TezosToolkit.prototype, \"stream\", {\n    /**\r\n     * @description Provide access to streaming utilities backed by an streamer implementation\r\n     */\n    get: function () {\n      return this._stream;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TezosToolkit.prototype, \"rpc\", {\n    /**\r\n     * @description Provide access to the currently used rpc client\r\n     */\n    get: function () {\n      return this._context.rpc;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TezosToolkit.prototype, \"signer\", {\n    /**\r\n     * @description Provide access to the currently used signer\r\n     */\n    get: function () {\n      return this._context.signer;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  TezosToolkit.prototype.importKey = function (privateKeyOrEmail, passphrase, mnemonic, secret) {\n    return __awaiter(this, void 0, void 0, function () {\n      var previousSigner, signer, pkh, op, ex_1, isInvalidActivationError, ex_2;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!(privateKeyOrEmail && passphrase && mnemonic && secret)) return [3\n            /*break*/\n            , 11];\n            previousSigner = this.signer;\n            signer = InMemorySigner.fromFundraiser(privateKeyOrEmail, passphrase, mnemonic);\n            return [4\n            /*yield*/\n            , signer.publicKeyHash()];\n\n          case 1:\n            pkh = _a.sent();\n            this.setSignerProvider(signer);\n            _a.label = 2;\n\n          case 2:\n            _a.trys.push([2, 9,, 10]);\n\n            op = void 0;\n            _a.label = 3;\n\n          case 3:\n            _a.trys.push([3, 5,, 6]);\n\n            return [4\n            /*yield*/\n            , this.tz.activate(pkh, secret)];\n\n          case 4:\n            op = _a.sent();\n            return [3\n            /*break*/\n            , 6];\n\n          case 5:\n            ex_1 = _a.sent();\n            isInvalidActivationError = ex_1 && ex_1.body && /Invalid activation/.test(ex_1.body);\n\n            if (!isInvalidActivationError) {\n              throw ex_1;\n            }\n\n            return [3\n            /*break*/\n            , 6];\n\n          case 6:\n            if (!op) return [3\n            /*break*/\n            , 8];\n            return [4\n            /*yield*/\n            , op.confirmation()];\n\n          case 7:\n            _a.sent();\n\n            _a.label = 8;\n\n          case 8:\n            return [3\n            /*break*/\n            , 10];\n\n          case 9:\n            ex_2 = _a.sent(); // Restore to previous signer in case of error\n\n            this.setSignerProvider(previousSigner);\n            throw ex_2;\n\n          case 10:\n            return [3\n            /*break*/\n            , 12];\n\n          case 11:\n            // Fallback to regular import\n            this.setSignerProvider(new InMemorySigner(privateKeyOrEmail, passphrase));\n            _a.label = 12;\n\n          case 12:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  TezosToolkit.prototype.getFactory = function (ctor) {\n    var _this = this;\n\n    return function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      return new (ctor.bind.apply(ctor, __spread([void 0, _this._context], args)))();\n    };\n  };\n\n  return TezosToolkit;\n}();\n/**\r\n * @description Default Tezos toolkit instance\r\n */\n\n\nvar Tezos = new TezosToolkit();\nexport { BigMapAbstraction, CompositeForger, DEFAULT_FEE, DEFAULT_GAS_LIMIT, DEFAULT_STORAGE_LIMIT, InvalidDelegationSource, InvalidParameterError, MANAGER_LAMBDA, PollingSubscribeProvider, Protocols, RpcForger, Tezos, TezosOperationError, TezosPreapplyFailureError, TezosToolkit, protocols };","map":{"version":3,"sources":["../src/signer/noop.ts","../src/forger/rpc-forger.ts","../src/injector/rpc-injector.ts","../src/context.ts","../src/operations/operations.ts","../src/operations/delegate-operation.ts","../src/constants.ts","../src/operations/operation-errors.ts","../src/operations/types.ts","../src/operations/operation-emitter.ts","../src/operations/origination-operation.ts","../src/operations/transaction-operation.ts","../src/contract/errors.ts","../src/contract/contract.ts","../src/format.ts","../src/contract/prepare.ts","../src/contract/big-map.ts","../src/contract/semantic.ts","../src/contract/rpc-contract-provider.ts","../src/contract/estimate.ts","../src/contract/rpc-estimate-provider.ts","../src/subscribe/filters.ts","../src/subscribe/observable-subscription.ts","../src/subscribe/polling-provider.ts","../src/tz/rpc-tz-provider.ts","../src/operations/batch-operation.ts","../src/batch/rpc-batch-provider.ts","../src/contract/manager-lambda.ts","../src/forger/composite-forger.ts","../src/taquito.ts"],"names":[],"mappings":"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","sourcesContent":["import { Signer } from './interface';\n\nexport class UnconfiguredSignerError implements Error {\n  name = 'UnconfiguredSignerError';\n  message =\n    'No signer has been configured. Please configure one by calling setProvider({signer}) on your TezosToolkit instance.';\n}\n\n/**\n * @description Default signer implementation which does nothing and produce invalid signature\n */\nexport class NoopSigner implements Signer {\n  async publicKey(): Promise<string> {\n    throw new UnconfiguredSignerError();\n  }\n  async publicKeyHash(): Promise<string> {\n    throw new UnconfiguredSignerError();\n  }\n  async secretKey(): Promise<string> {\n    throw new UnconfiguredSignerError();\n  }\n  async sign(_bytes: string, _watermark?: Uint8Array): Promise<any> {\n    throw new UnconfiguredSignerError();\n  }\n}\n","import { Forger, ForgeParams, ForgeResponse } from './interface';\nimport { Context } from '../context';\n\nexport class RpcForger implements Forger {\n  constructor(private context: Context) {}\n\n  forge({ branch, contents }: ForgeParams): Promise<ForgeResponse> {\n    return this.context.rpc.forgeOperations({ branch, contents });\n  }\n}\n","import { Injector } from './interface';\nimport { Context } from '../context';\n\nexport class RpcInjector implements Injector {\n  constructor(private context: Context) {}\n  inject(signedOperationBytes: string): Promise<string> {\n    return this.context.rpc.injectOperation(signedOperationBytes);\n  }\n}\n","import { RpcClient } from '@taquito/rpc';\nimport { Signer } from './signer/interface';\nimport { NoopSigner } from './signer/noop';\nimport { Protocols } from './constants';\nimport { Forger } from './forger/interface';\nimport { RpcForger } from './forger/rpc-forger';\nimport { Injector } from './injector/interface';\nimport { RpcInjector } from './injector/rpc-injector';\n\nexport interface TaquitoProvider<T, K extends Array<any>> {\n  new (context: Context, ...rest: K): T;\n}\n\nexport interface Config {\n  confirmationPollingIntervalSecond?: number;\n  confirmationPollingTimeoutSecond?: number;\n  defaultConfirmationCount?: number;\n}\n\nexport const defaultConfig: Required<Config> = {\n  confirmationPollingIntervalSecond: 10,\n  defaultConfirmationCount: 1,\n  confirmationPollingTimeoutSecond: 180,\n};\n\n/**\n * @description Encapsulate common service used throughout different part of the library\n */\nexport class Context {\n  private _forger: Forger;\n  private _injector: Injector;\n\n  constructor(\n    private _rpcClient: RpcClient = new RpcClient(),\n    private _signer: Signer = new NoopSigner(),\n    private _proto?: Protocols,\n    private _config?: Partial<Config>,\n    forger?: Forger,\n    injector?: Injector\n  ) {\n    this.config = _config as any;\n    this._forger = forger ? forger : new RpcForger(this);\n    this._injector = injector ? injector : new RpcInjector(this);\n  }\n\n  get config(): Required<Config> {\n    return this._config as any;\n  }\n\n  set config(value: Required<Config>) {\n    this._config = {\n      ...defaultConfig,\n      ...value,\n    };\n  }\n\n  get rpc(): RpcClient {\n    return this._rpcClient;\n  }\n\n  set rpc(value: RpcClient) {\n    this._rpcClient = value;\n  }\n\n  get injector() {\n    return this._injector;\n  }\n\n  set injector(value: Injector) {\n    this._injector = value;\n  }\n\n  get forger() {\n    return this._forger;\n  }\n\n  set forger(value: Forger) {\n    this._forger = value;\n  }\n\n  get signer() {\n    return this._signer;\n  }\n\n  set signer(value: Signer) {\n    this._signer = value;\n  }\n\n  set proto(value: Protocols | undefined) {\n    this._proto = value;\n  }\n\n  get proto() {\n    return this._proto;\n  }\n\n  async isAnyProtocolActive(protocol: string[] = []) {\n    if (this._proto) {\n      return protocol.includes(this._proto);\n    } else {\n      const { next_protocol } = await this.rpc.getBlockMetadata();\n      return protocol.includes(next_protocol);\n    }\n  }\n\n  /**\n   * @description Create a copy of the current context. Useful when you have long running operation and you do not want a context change to affect the operation\n   */\n  clone(): Context {\n    return new Context(this.rpc, this.signer, this.proto, this.config, this.forger, this._injector);\n  }\n}\n","import { BlockResponse, OperationContentsAndResult, OperationResultStatusEnum } from '@taquito/rpc';\nimport { defer, from, ReplaySubject, timer } from 'rxjs';\nimport {\n  filter,\n  first,\n  map,\n  mapTo,\n  shareReplay,\n  switchMap,\n  switchMapTo,\n  tap,\n} from 'rxjs/operators';\nimport { Context } from '../context';\nimport { ForgedBytes } from './types';\n\ninterface PollingConfig {\n  timeout: number;\n  interval: number;\n}\n\n/**\n * @description Utility class to interact with Tezos operations\n */\nexport class Operation {\n  private _pollingConfig$ = new ReplaySubject<PollingConfig>(1);\n\n  private _currentHeadPromise: Promise<BlockResponse> | undefined = undefined;\n\n  // Caching the current head for one second\n  private currentHead$ = defer(() => {\n    if (!this._currentHeadPromise) {\n      this._currentHeadPromise = this.context.rpc.getBlock();\n      timer(1000)\n        .pipe(first())\n        .subscribe(() => {\n          this._currentHeadPromise = undefined;\n        });\n    }\n    return from(this._currentHeadPromise);\n  });\n\n  // Polling observable that emit until timeout is reached\n  private polling$ = defer(() =>\n    this._pollingConfig$.pipe(\n      tap(({ timeout, interval }) => {\n        if (timeout <= 0) {\n          throw new Error('Timeout must be more than 0');\n        }\n\n        if (interval <= 0) {\n          throw new Error('Interval must be more than 0');\n        }\n      }),\n      map(config => ({\n        ...config,\n        timeoutAt: Math.ceil(config.timeout / config.interval) + 1,\n        count: 0,\n      })),\n      switchMap(config => timer(0, config.interval * 1000).pipe(mapTo(config))),\n      tap(config => {\n        config.count++;\n        if (config.count > config.timeoutAt) {\n          throw new Error(`Confirmation polling timed out`);\n        }\n      })\n    )\n  );\n\n  // Observable that emit once operation is seen in a block\n  private confirmed$ = this.polling$.pipe(\n    switchMapTo(this.currentHead$),\n    map(head => {\n      for (let i = 3; i >= 0; i--) {\n        head.operations[i].forEach(op => {\n          if (op.hash === this.hash) {\n            this._foundAt = head.header.level;\n          }\n        });\n      }\n\n      if (head.header.level - this._foundAt >= 0) {\n        return this._foundAt;\n      }\n    }),\n    filter(x => x !== undefined),\n    first(),\n    shareReplay()\n  );\n\n  protected _foundAt = Number.POSITIVE_INFINITY;\n  get includedInBlock() {\n    return this._foundAt;\n  }\n  /**\n   *\n   * @param hash Operation hash\n   * @param raw Raw operation that was injected\n   * @param context Taquito context allowing access to rpc and signer\n   */\n  constructor(\n    public readonly hash: string,\n    public readonly raw: ForgedBytes,\n    public readonly results: OperationContentsAndResult[],\n    protected readonly context: Context\n  ) {\n    this.confirmed$.pipe(first()).subscribe();\n  }\n\n  public get status() {\n    return (\n      this.results.map(result => {\n        if (result.metadata && result.metadata.operation_result) {\n          return result.metadata.operation_result.status as OperationResultStatusEnum;\n        } else {\n          return 'unknown';\n        }\n      })[0] || 'unknown'\n    );\n  }\n\n  /**\n   *\n   * @param confirmations [0] Number of confirmation to wait for\n   * @param interval [10] Polling interval\n   * @param timeout [180] Timeout\n   */\n  confirmation(confirmations?: number, interval?: number, timeout?: number) {\n    if (typeof confirmations !== 'undefined' && confirmations < 1) {\n      throw new Error('Confirmation count must be at least 1');\n    }\n\n    const {\n      defaultConfirmationCount,\n      confirmationPollingIntervalSecond,\n      confirmationPollingTimeoutSecond,\n    } = this.context.config;\n    this._pollingConfig$.next({\n      interval: interval || confirmationPollingIntervalSecond,\n      timeout: timeout || confirmationPollingTimeoutSecond,\n    } as Required<PollingConfig>);\n\n    const conf = confirmations !== undefined ? confirmations : defaultConfirmationCount;\n\n    return new Promise<number>((resolve, reject) => {\n      this.confirmed$\n        .pipe(\n          switchMap(() => this.polling$),\n          switchMap(() => this.currentHead$),\n          filter(head => head.header.level - this._foundAt >= conf - 1),\n          first()\n        )\n        .subscribe(_ => {\n          resolve(this._foundAt + (conf - 1));\n        }, reject);\n    });\n  }\n}\n","import { OperationContentsAndResult, OperationContentsAndResultDelegation } from '@taquito/rpc';\nimport { Context } from '../context';\nimport { Operation } from './operations';\nimport {\n  FeeConsumingOperation,\n  ForgedBytes,\n  GasConsumingOperation,\n  RPCDelegateOperation,\n  StorageConsumingOperation,\n} from './types';\n\n/**\n * @description Delegation operation provide utility function to fetch newly issued delegation\n *\n * @warn Currently support only one delegation per operation\n */\nexport class DelegateOperation extends Operation\n  implements GasConsumingOperation, StorageConsumingOperation, FeeConsumingOperation {\n  constructor(\n    hash: string,\n    private readonly params: RPCDelegateOperation,\n    public readonly source: string,\n    raw: ForgedBytes,\n    results: OperationContentsAndResult[],\n    context: Context\n  ) {\n    super(hash, raw, results, context);\n  }\n\n  get operationResults() {\n    const delegationOp =\n      Array.isArray(this.results) &&\n      (this.results.find(op => op.kind === 'delegation') as OperationContentsAndResultDelegation);\n    const result = delegationOp && delegationOp.metadata && delegationOp.metadata.operation_result;\n    return result ? result : undefined;\n  }\n\n  get delegate(): string {\n    return this.delegate;\n  }\n\n  get isRegisterOperation(): boolean {\n    return this.delegate === this.source;\n  }\n\n  get fee() {\n    return this.params.fee;\n  }\n\n  get gasLimit() {\n    return this.params.gas_limit;\n  }\n\n  get storageLimit() {\n    return this.params.storage_limit;\n  }\n\n  get consumedGas() {\n    const consumedGas = this.operationResults && this.operationResults.consumed_gas;\n    return consumedGas ? consumedGas : undefined;\n  }\n\n  get errors() {\n    return this.operationResults && this.operationResults.errors;\n  }\n}\n","export enum DEFAULT_GAS_LIMIT {\n  DELEGATION = 10600,\n  ORIGINATION = 10600,\n  TRANSFER = 10600,\n  REVEAL = 10600,\n}\nexport enum DEFAULT_FEE {\n  DELEGATION = 1257,\n  ORIGINATION = 10000,\n  TRANSFER = 10000,\n  REVEAL = 1420,\n}\nexport enum DEFAULT_STORAGE_LIMIT {\n  DELEGATION = 0,\n  ORIGINATION = 257,\n  TRANSFER = 257,\n  REVEAL = 0,\n}\n\nexport enum Protocols {\n  Pt24m4xi = 'Pt24m4xiPbLDhVgVfABUjirbmda3yohdN82Sp9FeuAXJ4eV9otd',\n  PsBABY5H = 'PsBABY5HQTSkA4297zNHfsZNKtxULfL18y95qb3m53QJiXGmrbU',\n  PsBabyM1 = 'PsBabyM1eUXZseaJdmXFApDSBqj8YBfwELoxZHHW77EMcAbbwAS',\n  PsCARTHA = 'PsCARTHAGazKbHtnKfLzQg3kms52kSRpgnDY982a9oYsSXRLQEb',\n}\n\nexport const protocols = {\n  '004': [Protocols.Pt24m4xi],\n  '005': [Protocols.PsBABY5H, Protocols.PsBabyM1],\n  '006': [Protocols.PsCARTHA],\n};\n","import {\n  MichelsonV1ExpressionBase,\n  PreapplyResponse,\n  TezosGenericOperationError,\n} from '@taquito/rpc';\n\nexport interface TezosOperationErrorWithMessage extends TezosGenericOperationError {\n  with: MichelsonV1ExpressionBase;\n}\n\nconst isErrorWithMessage = (error: any): error is TezosOperationErrorWithMessage => {\n  return 'with' in error;\n};\n\nexport class TezosOperationError implements Error {\n  name: string = 'TezosOperationError';\n  id: string;\n  kind: string;\n  message: string;\n\n  constructor(public errors: TezosGenericOperationError[]) {\n    // Last error is 'often' the one with more detail\n    const lastError = errors[errors.length - 1];\n\n    this.id = lastError.id;\n    this.kind = lastError.kind;\n\n    this.message = `(${this.kind}) ${this.id}`;\n\n    if (isErrorWithMessage(lastError) && lastError.with.string) {\n      this.message = lastError.with.string;\n    }\n  }\n}\n\nexport class TezosPreapplyFailureError implements Error {\n  name: string = 'TezosPreapplyFailureError';\n  message: string = 'Preapply returned an unexpected result';\n\n  constructor(public result: any) {}\n}\n\nexport const flattenOperationResult = (response: PreapplyResponse | PreapplyResponse[]) => {\n  let results = Array.isArray(response) ? response : [response];\n\n  let returnedResults: any[] = [];\n  for (let i = 0; i < results.length; i++) {\n    for (let j = 0; j < results[i].contents.length; j++) {\n      const content = results[i].contents[j];\n      if ('metadata' in content && typeof content.metadata.operation_result !== 'undefined') {\n        returnedResults.push(content.metadata.operation_result);\n\n        if (Array.isArray(content.metadata.internal_operation_results)) {\n          content.metadata.internal_operation_results.forEach((x: any) =>\n            returnedResults.push(x.result)\n          );\n        }\n      }\n    }\n  }\n\n  return returnedResults;\n};\n\n/***\n * @description Flatten all error from preapply response (including internal error)\n */\nexport const flattenErrors = (\n  response: PreapplyResponse | PreapplyResponse[],\n  status = 'failed'\n) => {\n  let results = Array.isArray(response) ? response : [response];\n\n  let errors: TezosGenericOperationError[] = [];\n  // Transaction that do not fail will be backtracked in case one failure occur\n  for (let i = 0; i < results.length; i++) {\n    for (let j = 0; j < results[i].contents.length; j++) {\n      const content = results[i].contents[j];\n      if ('metadata' in content) {\n        if (\n          typeof content.metadata.operation_result !== 'undefined' &&\n          content.metadata.operation_result.status === status\n        ) {\n          errors = errors.concat(content.metadata.operation_result.errors || []);\n        }\n        if (Array.isArray(content.metadata.internal_operation_results)) {\n          for (const internalResult of content.metadata.internal_operation_results) {\n            if ('result' in internalResult && internalResult.result.status === status) {\n              errors = errors.concat(internalResult.result.errors || []);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return errors;\n};\n","import { OperationObject, InternalOperationResultKindEnum, OpKind } from '@taquito/rpc';\n\nexport { OpKind } from '@taquito/rpc';\n\nexport type withKind<T, K extends OpKind> = T & { kind: K };\n\nexport type ParamsWithKind =\n  | withKind<OriginateParams, OpKind.ORIGINATION>\n  | withKind<DelegateParams, OpKind.DELEGATION>\n  | withKind<TransferParams, OpKind.TRANSACTION>\n  | withKind<ActivationParams, OpKind.ACTIVATION>;\n\nexport const isKind = <T extends { kind: OpKind }, K extends OpKind>(\n  op: T,\n  kind: K\n): op is withKind<T, K> => {\n  return op.kind === kind;\n};\n\nexport type RPCOpWithFee =\n  | RPCTransferOperation\n  | RPCOriginationOperation\n  | RPCDelegateOperation\n  | RPCRevealOperation;\nexport type RPCOpWithSource =\n  | RPCTransferOperation\n  | RPCOriginationOperation\n  | RPCDelegateOperation\n  | RPCRevealOperation;\n\nexport const isOpWithFee = <T extends { kind: OpKind }>(\n  op: T\n): op is withKind<T, InternalOperationResultKindEnum> => {\n  return ['transaction', 'delegation', 'origination', 'reveal'].indexOf(op.kind) !== -1;\n};\n\nexport const isOpRequireReveal = <T extends { kind: OpKind }>(\n  op: T\n): op is withKind<T, Exclude<InternalOperationResultKindEnum, OpKind.REVEAL>> => {\n  return ['transaction', 'delegation', 'origination'].indexOf(op.kind) !== -1;\n};\n\nexport type SourceKinds = InternalOperationResultKindEnum;\n\nexport const isSourceOp = <T extends { kind: OpKind }>(op: T): op is withKind<T, SourceKinds> => {\n  return ['transaction', 'delegation', 'origination', 'reveal', 'ballot'].indexOf(op.kind) !== -1;\n};\n\nexport interface GasConsumingOperation {\n  consumedGas?: string;\n  gasLimit: number;\n}\n\nexport interface StorageConsumingOperation {\n  storageDiff?: string;\n  storageSize?: string;\n  storageLimit: number;\n}\n\nexport interface FeeConsumingOperation {\n  fee: number;\n}\n\nexport type OriginateParamsBase = {\n  balance?: string;\n  code: string | object[];\n  delegate?: string;\n  fee?: number;\n  gasLimit?: number;\n  storageLimit?: number;\n};\n\n/**\n * @description Parameters for originate method\n */\nexport type OriginateParams = OriginateParamsBase &\n  (\n    | {\n        init?: never;\n        storage: any;\n      }\n    | {\n        init: string | object;\n        storage?: never;\n      }\n  );\n\nexport interface ActivationParams {\n  pkh: string;\n  secret: string;\n}\n\n/**\n * @description RPC origination operation\n */\nexport interface RPCOriginationOperation {\n  kind: OpKind.ORIGINATION;\n  fee: number;\n  gas_limit: number;\n  storage_limit: number;\n  balance: string;\n  delegate?: string;\n  source?: string;\n  script: {\n    code: any;\n    storage: any;\n  };\n}\n\n/**\n * @description RPC reveal operation\n */\nexport interface RPCRevealOperation {\n  kind: OpKind.REVEAL;\n  fee: number;\n  public_key: string;\n  source?: string;\n  gas_limit: number;\n  storage_limit: number;\n}\n\n/**\n * @description Result of a forge operation contains the operation plus its encoded version\n */\nexport interface ForgedBytes {\n  opbytes: string;\n  opOb: OperationObject;\n  counter: number;\n}\n\n/**\n * @description Parameters for setDelegate method\n */\nexport interface DelegateParams {\n  source: string;\n  delegate: string;\n  fee?: number;\n  gasLimit?: number;\n  storageLimit?: number;\n}\n\n/**\n * @description Parameters for registerDelegate method\n */\nexport interface RegisterDelegateParams {\n  fee?: number;\n  gasLimit?: number;\n  storageLimit?: number;\n}\n\n/**\n * @description RPC delegation operation\n */\nexport interface RPCDelegateOperation {\n  kind: OpKind.DELEGATION;\n  source?: string;\n  fee: number;\n  gas_limit: number;\n  storage_limit: number;\n  delegate: string;\n}\n\n/**\n * @description Parameters for transfer method\n */\nexport interface TransferParams {\n  to: string;\n  source?: string;\n  amount: number;\n  fee?: number;\n  parameter?: string | object | { entrypoint: string; value: object };\n  gasLimit?: number;\n  storageLimit?: number;\n  mutez?: boolean;\n  rawParam?: boolean;\n}\n\n/**\n * @description RPC transfer operation\n */\nexport interface RPCTransferOperation {\n  kind: OpKind.TRANSACTION;\n  fee: number;\n  gas_limit: number;\n  storage_limit: number;\n  amount: string;\n  source?: string;\n  destination: string;\n  parameters?: any;\n}\n\n/**\n * @description RPC activate account operation\n */\nexport interface RPCActivateOperation {\n  kind: OpKind.ACTIVATION;\n  pkh: string;\n  secret: string;\n}\n\nexport type RPCOperation =\n  | RPCOriginationOperation\n  | RPCTransferOperation\n  | RPCDelegateOperation\n  | RPCRevealOperation\n  | RPCActivateOperation;\n\nexport type PrepareOperationParams = {\n  operation: RPCOperation | RPCOperation[];\n  source?: string;\n};\n","import {\n  BlockHeaderResponse,\n  ManagerKeyResponse,\n  OperationContents,\n  OperationContentsAndResult,\n  OpKind,\n  RpcClient,\n  RPCRunOperationParam,\n} from '@taquito/rpc';\nimport { DEFAULT_FEE, DEFAULT_GAS_LIMIT, DEFAULT_STORAGE_LIMIT, Protocols } from '../constants';\nimport { Context } from '../context';\nimport { Estimate } from '../contract/estimate';\nimport { flattenErrors, TezosOperationError, TezosPreapplyFailureError } from './operation-errors';\nimport {\n  ForgedBytes,\n  isOpRequireReveal,\n  PrepareOperationParams,\n  RPCOperation,\n  RPCOpWithFee,\n  RPCOpWithSource,\n  RPCRevealOperation,\n} from './types';\n\nexport interface PreparedOperation {\n  opOb: {\n    branch: string;\n    contents: OperationContents[];\n    protocol: string;\n  };\n  counter: number;\n}\n\nexport abstract class OperationEmitter {\n  get rpc(): RpcClient {\n    return this.context.rpc;\n  }\n\n  get signer() {\n    return this.context.signer;\n  }\n\n  constructor(protected context: Context) {}\n\n  // Originally from sotez (Copyright (c) 2018 Andrew Kishino)\n  protected async prepareOperation({\n    operation,\n    source,\n  }: PrepareOperationParams): Promise<PreparedOperation> {\n    let counter;\n    const counters: { [key: string]: number } = {};\n    let requiresReveal = false;\n    let ops: RPCOperation[] = [];\n    let head: BlockHeaderResponse;\n\n    const blockHeaderPromise = this.rpc.getBlockHeader();\n    const blockMetaPromise = this.rpc.getBlockMetadata();\n\n    if (Array.isArray(operation)) {\n      ops = [...operation];\n    } else {\n      ops = [operation];\n    }\n\n    // Implicit account who emit the operation\n    const publicKeyHash = await this.signer.publicKeyHash();\n\n    let counterPromise: Promise<string | undefined> = Promise.resolve(undefined);\n    let managerPromise: Promise<ManagerKeyResponse | undefined> = Promise.resolve(undefined);\n    for (let i = 0; i < ops.length; i++) {\n      if (isOpRequireReveal(ops[i])) {\n        requiresReveal = true;\n        const { counter } = await this.rpc.getContract(publicKeyHash);\n        counterPromise = Promise.resolve(counter);\n        managerPromise = this.rpc.getManagerKey(publicKeyHash);\n        break;\n      }\n    }\n\n    const [header, metadata, headCounter, manager] = await Promise.all([\n      blockHeaderPromise,\n      blockMetaPromise,\n      counterPromise,\n      managerPromise as any,\n    ]);\n\n    if (!header) {\n      throw new Error('Unable to latest block header');\n    }\n\n    if (!metadata) {\n      throw new Error('Unable to fetch latest metadata');\n    }\n\n    head = header;\n\n    if (requiresReveal) {\n      const haveManager = manager && typeof manager === 'object' ? !!manager.key : !!manager;\n      if (!haveManager) {\n        const reveal: RPCRevealOperation = {\n          kind: OpKind.REVEAL,\n          fee: DEFAULT_FEE.REVEAL,\n          public_key: await this.signer.publicKey(),\n          source: publicKeyHash,\n          gas_limit: DEFAULT_GAS_LIMIT.REVEAL,\n          storage_limit: DEFAULT_STORAGE_LIMIT.REVEAL,\n        };\n\n        ops.unshift(reveal);\n      }\n    }\n\n    counter = parseInt(headCounter || '0', 10);\n    if (!counters[publicKeyHash] || counters[publicKeyHash] < counter) {\n      counters[publicKeyHash] = counter;\n    }\n\n    const getFee = (op: RPCOpWithFee) => {\n      const opCounter = ++counters[publicKeyHash];\n      return {\n        counter: `${opCounter}`,\n        // tslint:disable-next-line: strict-type-predicates\n        fee: typeof op.fee === 'undefined' ? '0' : `${op.fee}`,\n        // tslint:disable-next-line: strict-type-predicates\n        gas_limit: typeof op.gas_limit === 'undefined' ? '0' : `${op.gas_limit}`,\n        // tslint:disable-next-line: strict-type-predicates\n        storage_limit: typeof op.storage_limit === 'undefined' ? '0' : `${op.storage_limit}`,\n      };\n    };\n\n    const getSource = (op: RPCOpWithSource) => {\n      return {\n        source: typeof op.source === 'undefined' ? source || publicKeyHash : op.source,\n      };\n    };\n\n    const constructOps = (cOps: RPCOperation[]): OperationContents[] =>\n      // tslint:disable strict-type-predicates\n      cOps.map((op: RPCOperation) => {\n        switch (op.kind) {\n          case OpKind.ACTIVATION:\n            return {\n              ...op,\n            };\n          case OpKind.REVEAL:\n            return {\n              ...op,\n              ...getSource(op),\n              ...getFee(op),\n            };\n          case OpKind.ORIGINATION:\n            return {\n              ...op,\n              balance: typeof op.balance !== 'undefined' ? `${op.balance}` : '0',\n              ...getSource(op),\n              ...getFee(op),\n            };\n          case OpKind.TRANSACTION:\n            const cops = {\n              ...op,\n              amount: typeof op.amount !== 'undefined' ? `${op.amount}` : '0',\n              ...getSource(op),\n              ...getFee(op),\n            };\n            if (cops.source.toLowerCase().startsWith('kt1')) {\n              throw new Error(\n                `KT1 addresses are not supported as source since ${Protocols.PsBabyM1}`\n              );\n            }\n            return cops;\n          case OpKind.DELEGATION:\n            return {\n              ...op,\n              ...getSource(op),\n              ...getFee(op),\n            };\n          default:\n            throw new Error('Unsupported operation');\n        }\n      });\n\n    const branch = head.hash;\n    const contents = constructOps(ops);\n    const protocol = metadata.next_protocol;\n\n    return {\n      opOb: {\n        branch,\n        contents,\n        protocol,\n      },\n      counter,\n    };\n  }\n\n  protected async prepareAndForge(params: PrepareOperationParams) {\n    const prepared = await this.prepareOperation(params);\n    return this.forge(prepared);\n  }\n\n  protected async forge({ opOb: { branch, contents, protocol }, counter }: PreparedOperation) {\n    let forgedBytes = await this.context.forger.forge({ branch, contents });\n\n    return {\n      opbytes: forgedBytes,\n      opOb: {\n        branch,\n        contents,\n        protocol,\n      },\n      counter,\n    };\n  }\n\n  protected async simulate(op: RPCRunOperationParam) {\n    return {\n      opResponse: await this.rpc.runOperation(op),\n      op,\n      context: this.context.clone(),\n    };\n  }\n\n  protected async estimate<T extends { fee?: number; gasLimit?: number; storageLimit?: number }>(\n    { fee, gasLimit, storageLimit, ...rest }: T,\n    estimator: (param: T) => Promise<Estimate>\n  ) {\n    let calculatedFee = fee;\n    let calculatedGas = gasLimit;\n    let calculatedStorage = storageLimit;\n\n    if (fee === undefined || gasLimit === undefined || storageLimit === undefined) {\n      const estimation = await estimator({ fee, gasLimit, storageLimit, ...(rest as any) });\n\n      if (calculatedFee === undefined) {\n        calculatedFee = estimation.suggestedFeeMutez;\n      }\n\n      if (calculatedGas === undefined) {\n        calculatedGas = estimation.gasLimit;\n      }\n\n      if (calculatedStorage === undefined) {\n        calculatedStorage = estimation.storageLimit;\n      }\n    }\n\n    return {\n      fee: calculatedFee!,\n      gasLimit: calculatedGas!,\n      storageLimit: calculatedStorage!,\n    };\n  }\n\n  protected async signAndInject(forgedBytes: ForgedBytes) {\n    const signed = await this.signer.sign(forgedBytes.opbytes, new Uint8Array([3]));\n    forgedBytes.opbytes = signed.sbytes;\n    forgedBytes.opOb.signature = signed.prefixSig;\n\n    const opResponse: OperationContentsAndResult[] = [];\n    const results = await this.rpc.preapplyOperations([forgedBytes.opOb]);\n\n    if (!Array.isArray(results)) {\n      throw new TezosPreapplyFailureError(results);\n    }\n\n    for (let i = 0; i < results.length; i++) {\n      for (let j = 0; j < results[i].contents.length; j++) {\n        opResponse.push(results[i].contents[j]);\n      }\n    }\n\n    const errors = flattenErrors(results);\n\n    if (errors.length) {\n      // @ts-ignore\n      throw new TezosOperationError(errors);\n    }\n\n    return {\n      hash: await this.context.injector.inject(forgedBytes.opbytes),\n      forgedBytes,\n      opResponse,\n      context: this.context.clone(),\n    };\n  }\n}\n","import {\n  OperationContentsAndResult,\n  OperationContentsAndResultOrigination,\n  OpKind,\n} from '@taquito/rpc';\nimport { Context } from '../context';\nimport { RpcContractProvider } from '../contract/rpc-contract-provider';\nimport { Operation } from './operations';\nimport {\n  ForgedBytes,\n  GasConsumingOperation,\n  StorageConsumingOperation,\n  RPCOriginationOperation,\n  FeeConsumingOperation,\n  withKind,\n} from './types';\n\n/**\n * @description Origination operation provide utility function to fetch newly originated contract\n *\n * @warn Currently support only one origination per operation\n */\nexport class OriginationOperation extends Operation\n  implements GasConsumingOperation, StorageConsumingOperation, FeeConsumingOperation {\n  /**\n   * @description Contract address of the newly originated contract\n   */\n  public readonly contractAddress?: string;\n\n  constructor(\n    hash: string,\n    private readonly params: RPCOriginationOperation,\n    raw: ForgedBytes,\n    results: OperationContentsAndResult[],\n    context: Context,\n    private contractProvider: RpcContractProvider\n  ) {\n    super(hash, raw, results, context);\n\n    const originatedContracts = this.operationResults && this.operationResults.originated_contracts;\n    if (Array.isArray(originatedContracts)) {\n      this.contractAddress = originatedContracts[0];\n    }\n  }\n\n  get operationResults() {\n    const originationOp =\n      Array.isArray(this.results) && this.results.find(op => op.kind === 'origination');\n\n    const result =\n      originationOp && originationOp.metadata && originationOp.metadata.operation_result;\n    return result ? result : undefined;\n  }\n\n  get fee() {\n    return this.params.fee;\n  }\n\n  get gasLimit() {\n    return this.params.gas_limit;\n  }\n\n  get storageLimit() {\n    return this.params.storage_limit;\n  }\n\n  get consumedGas() {\n    const consumedGas = this.operationResults && this.operationResults.consumed_gas;\n    return consumedGas ? consumedGas : undefined;\n  }\n\n  get storageDiff() {\n    const storageDiff = this.operationResults && this.operationResults.paid_storage_size_diff;\n    return storageDiff ? storageDiff : undefined;\n  }\n\n  get storageSize() {\n    const storageSize = this.operationResults && this.operationResults.storage_size;\n    return storageSize ? storageSize : undefined;\n  }\n\n  get errors() {\n    return this.operationResults && this.operationResults.errors;\n  }\n\n  /**\n   * @description Provide the contract abstract of the newly originated contract\n   */\n  async contract(confirmations?: number, interval?: number, timeout?: number) {\n    if (!this.contractAddress) {\n      throw new Error('No contract was originated in this operation');\n    }\n\n    await this.confirmation(confirmations, interval, timeout);\n    return this.contractProvider.at(this.contractAddress);\n  }\n}\n","import { OperationContentsAndResult, OperationContentsAndResultTransaction } from '@taquito/rpc';\nimport BigNumber from 'bignumber.js';\nimport { Context } from '../context';\nimport { flattenErrors, flattenOperationResult } from './operation-errors';\nimport { Operation } from './operations';\nimport {\n  FeeConsumingOperation,\n  ForgedBytes,\n  GasConsumingOperation,\n  RPCTransferOperation,\n  StorageConsumingOperation,\n} from './types';\n\n/**\n * @description Transaction operation provides utility functions to fetch a newly issued transaction\n *\n * @warn Currently supports one transaction per operation\n */\nexport class TransactionOperation extends Operation\n  implements GasConsumingOperation, StorageConsumingOperation, FeeConsumingOperation {\n  constructor(\n    hash: string,\n    private readonly params: RPCTransferOperation,\n    public readonly source: string,\n    raw: ForgedBytes,\n    results: OperationContentsAndResult[],\n    context: Context\n  ) {\n    super(hash, raw, results, context);\n  }\n\n  get operationResults() {\n    const transactionOp =\n      Array.isArray(this.results) &&\n      (this.results.find(op => op.kind === 'transaction') as OperationContentsAndResultTransaction);\n    return transactionOp ? [transactionOp] : [];\n  }\n\n  get amount() {\n    return new BigNumber(this.params.amount);\n  }\n\n  get destination() {\n    return this.params.destination;\n  }\n\n  get fee() {\n    return this.params.fee;\n  }\n\n  get gasLimit() {\n    return this.params.gas_limit;\n  }\n\n  get storageLimit() {\n    return this.params.storage_limit;\n  }\n\n  private sumProp(arr: any[], prop: string) {\n    return arr.reduce((prev, current) => {\n      return prop in current ? Number(current[prop]) + prev : prev;\n    }, 0);\n  }\n\n  get consumedGas() {\n    return String(\n      this.sumProp(flattenOperationResult({ contents: this.operationResults }), 'consumed_gas')\n    );\n  }\n\n  get storageDiff() {\n    return String(\n      this.sumProp(\n        flattenOperationResult({ contents: this.operationResults }),\n        'paid_storage_size_diff'\n      )\n    );\n  }\n\n  get storageSize() {\n    return String(\n      this.sumProp(flattenOperationResult({ contents: this.operationResults }), 'storage_size')\n    );\n  }\n\n  get errors() {\n    return flattenErrors({ contents: this.operationResults });\n  }\n}\n","export class InvalidParameterError implements Error {\n  name: string = 'Invalid parameters error';\n  message: string;\n  constructor(public smartContractMethodName: string, public sigs: any[], public args: any[]) {\n    this.message = `${smartContractMethodName} Received ${\n      args.length\n    } arguments while expecting on of the follow signatures (${JSON.stringify(sigs)})`;\n  }\n}\n\nexport class InvalidDelegationSource implements Error {\n  name: string = 'Invalid delegation source error';\n  message: string;\n\n  constructor(public source: string) {\n    this.message = `Since Babylon delegation source can no longer be a contract address ${source}. Please use the smart contract abstraction to set your delegate.`;\n  }\n}\n","import { ParameterSchema, Schema } from '@taquito/michelson-encoder';\nimport { EntrypointsResponse, ScriptResponse } from '@taquito/rpc';\nimport { ContractProvider } from './interface';\nimport { InvalidParameterError } from './errors';\nimport { TransferParams } from '../operations/types';\n\ninterface SendParams {\n  fee?: number;\n  storageLimit?: number;\n  gasLimit?: number;\n  amount: number;\n  source?: string;\n  mutez?: boolean;\n}\n\n// Ensure that all parameter that are not in SendParams are defined\ntype ExplicitTransferParams = Required<Omit<TransferParams, keyof SendParams>> & SendParams;\n\nconst DEFAULT_SMART_CONTRACT_METHOD_NAME = 'main';\n\n/**\n * @description Utility class to send smart contract operation\n */\nexport class ContractMethod {\n  constructor(\n    private provider: ContractProvider,\n    private address: string,\n    private parameterSchema: ParameterSchema,\n    private name: string,\n    private args: any[],\n    private isMultipleEntrypoint = true,\n    private isAnonymous = false\n  ) {}\n\n  /**\n   * @description Get the schema of the smart contract method\n   */\n  get schema() {\n    return this.isAnonymous\n      ? this.parameterSchema.ExtractSchema()[this.name]\n      : this.parameterSchema.ExtractSchema();\n  }\n\n  /**\n   *\n   * @description Send the smart contract operation\n   *\n   * @param Options generic operation parameter\n   */\n  send(params: Partial<SendParams> = {}) {\n    return this.provider.transfer(this.toTransferParams(params));\n  }\n\n  /**\n   *\n   * @description Create transfer params to be used with TezosToolkit.contract.transfer methods\n   *\n   * @param Options generic transfer operation parameters\n   */\n  toTransferParams({\n    fee,\n    gasLimit,\n    storageLimit,\n    source,\n    amount = 0,\n    mutez = false,\n  }: Partial<SendParams> = {}): TransferParams {\n    const fullTransferParams: ExplicitTransferParams = {\n      to: this.address,\n      amount,\n      fee,\n      mutez,\n      source,\n      gasLimit,\n      storageLimit,\n      parameter: {\n        entrypoint: this.isMultipleEntrypoint ? this.name : 'default',\n        value: this.isAnonymous\n          ? this.parameterSchema.Encode(this.name, ...this.args)\n          : this.parameterSchema.Encode(...this.args),\n      },\n      rawParam: true,\n    };\n    return fullTransferParams;\n  }\n}\n\nconst validateArgs = (args: any[], schema: ParameterSchema, name: string) => {\n  const sigs = schema.ExtractSignatures();\n\n  if (!sigs.find((x: any[]) => x.length === args.length)) {\n    throw new InvalidParameterError(name, sigs, args);\n  }\n};\n\n/**\n * @description Smart contract abstraction\n */\nexport class Contract {\n  /**\n   * @description Contains methods that are implemented by the target Tezos Smart Contract, and offers the user to call the Smart Contract methods as if they were native TS/JS methods.\n   * NB: if the contract contains annotation it will include named properties; if not it will be indexed by a number.\n   *\n   */\n  public methods: { [key: string]: (...args: any[]) => ContractMethod } = {};\n\n  public readonly schema: Schema;\n\n  public readonly parameterSchema: ParameterSchema;\n\n  constructor(\n    public readonly address: string,\n    public readonly script: ScriptResponse,\n    private provider: ContractProvider,\n    private entrypoints: EntrypointsResponse\n  ) {\n    this.schema = Schema.fromRPCResponse({ script: this.script });\n    this.parameterSchema = ParameterSchema.fromRPCResponse({ script: this.script });\n    this._initializeMethods(address, provider, this.entrypoints.entrypoints);\n  }\n\n  private _initializeMethods(\n    address: string,\n    provider: ContractProvider,\n    entrypoints: {\n      [key: string]: object;\n    }\n  ) {\n    const parameterSchema = this.parameterSchema;\n    const keys = Object.keys(entrypoints);\n    if (parameterSchema.isMultipleEntryPoint) {\n      keys.forEach(smartContractMethodName => {\n        const method = function(...args: any[]) {\n          const smartContractMethodSchema = new ParameterSchema(\n            entrypoints[smartContractMethodName]\n          );\n\n          validateArgs(args, smartContractMethodSchema, smartContractMethodName);\n\n          return new ContractMethod(\n            provider,\n            address,\n            smartContractMethodSchema,\n            smartContractMethodName,\n            args\n          );\n        };\n        this.methods[smartContractMethodName] = method;\n      });\n\n      // Deal with methods with no annotations which were not discovered by the RPC endpoint\n      // Methods with no annotations are discovered using parameter schema\n      const anonymousMethods = Object.keys(parameterSchema.ExtractSchema()).filter(\n        key => Object.keys(entrypoints).indexOf(key) === -1\n      );\n\n      anonymousMethods.forEach(smartContractMethodName => {\n        const method = function(...args: any[]) {\n          validateArgs(\n            [smartContractMethodName, ...args],\n            parameterSchema,\n            smartContractMethodName\n          );\n          return new ContractMethod(\n            provider,\n            address,\n            parameterSchema,\n            smartContractMethodName,\n            args,\n            false,\n            true\n          );\n        };\n        this.methods[smartContractMethodName] = method;\n      });\n    } else {\n      const smartContractMethodSchema = this.parameterSchema;\n      const method = function(...args: any[]) {\n        validateArgs(args, parameterSchema, DEFAULT_SMART_CONTRACT_METHOD_NAME);\n        return new ContractMethod(\n          provider,\n          address,\n          smartContractMethodSchema,\n          DEFAULT_SMART_CONTRACT_METHOD_NAME,\n          args,\n          false\n        );\n      };\n      this.methods[DEFAULT_SMART_CONTRACT_METHOD_NAME] = method;\n    }\n  }\n\n  /**\n   * @description Return a friendly representation of the smart contract storage\n   */\n  public storage<T>() {\n    return this.provider.getStorage<T>(this.address, this.schema);\n  }\n\n  /**\n   *\n   * @description Return a friendly representation of the smart contract big map value\n   *\n   * @param key BigMap key to fetch\n   */\n  public bigMap(key: string) {\n    // tslint:disable-next-line: deprecation\n    return this.provider.getBigMapKey(this.address, key, this.schema);\n  }\n}\n","import BigNumber from 'bignumber.js';\n\nconst TZ_DECIMALS = 6;\nconst MTZ_DECIMALS = 3;\n\ntype Format = 'tz' | 'mtz' | 'mutez';\n\nfunction getDecimal(format: Format) {\n  switch (format) {\n    case 'tz':\n      return TZ_DECIMALS;\n    case 'mtz':\n      return MTZ_DECIMALS;\n    case 'mutez':\n    default:\n      return 0;\n  }\n}\n\nexport function format(\n  from: Format = 'mutez',\n  to: Format = 'mutez',\n  amount: number | string | BigNumber\n) {\n  const bigNum = new BigNumber(amount);\n  if (bigNum.isNaN()) {\n    return amount;\n  }\n\n  return bigNum\n    .multipliedBy(Math.pow(10, getDecimal(from)))\n    .dividedBy(Math.pow(10, getDecimal(to)));\n}\n","import {\n  OriginateParams,\n  RPCOriginationOperation,\n  TransferParams,\n  RPCTransferOperation,\n  DelegateParams,\n  RPCDelegateOperation,\n  RegisterDelegateParams,\n} from '../operations/types';\nimport { DEFAULT_FEE, DEFAULT_GAS_LIMIT, DEFAULT_STORAGE_LIMIT } from '../constants';\nimport { ml2mic, sexp2mic } from '@taquito/utils';\nimport { Schema } from '@taquito/michelson-encoder';\nimport { format } from '../format';\nimport { OpKind } from '@taquito/rpc';\n\nexport const createOriginationOperation = async ({\n  code,\n  init,\n  balance = '0',\n  delegate,\n  storage,\n  fee = DEFAULT_FEE.ORIGINATION,\n  gasLimit = DEFAULT_GAS_LIMIT.ORIGINATION,\n  storageLimit = DEFAULT_STORAGE_LIMIT.ORIGINATION,\n}: OriginateParams) => {\n  // tslint:disable-next-line: strict-type-predicates\n  if (storage !== undefined && init !== undefined) {\n    throw new Error(\n      'Storage and Init cannot be set a the same time. Please either use storage or init but not both.'\n    );\n  }\n\n  const contractCode = Array.isArray(code) ? code : ml2mic(code);\n\n  let contractStorage: object;\n  if (storage !== undefined) {\n    const schema = new Schema(contractCode[1].args[0]);\n    contractStorage = schema.Encode(storage);\n  } else {\n    contractStorage = typeof init === 'string' ? sexp2mic(init) : init;\n  }\n\n  const script = {\n    code: Array.isArray(code) ? code : ml2mic(code),\n    storage: contractStorage,\n  };\n\n  const operation: RPCOriginationOperation = {\n    kind: OpKind.ORIGINATION,\n    fee,\n    gas_limit: gasLimit,\n    storage_limit: storageLimit,\n    balance: format('tz', 'mutez', balance).toString(),\n    script,\n  };\n\n  if (delegate) {\n    operation.delegate = delegate;\n  }\n  return operation;\n};\n\nexport const createTransferOperation = async ({\n  to,\n  amount,\n  parameter,\n  fee = DEFAULT_FEE.TRANSFER,\n  gasLimit = DEFAULT_GAS_LIMIT.TRANSFER,\n  storageLimit = DEFAULT_STORAGE_LIMIT.TRANSFER,\n  mutez = false,\n  rawParam = false,\n}: TransferParams) => {\n  const operation: RPCTransferOperation = {\n    kind: OpKind.TRANSACTION,\n    fee,\n    gas_limit: gasLimit,\n    storage_limit: storageLimit,\n    amount: mutez ? amount.toString() : format('tz', 'mutez', amount).toString(),\n    destination: to,\n  };\n\n  if (parameter) {\n    operation.parameters = rawParam\n      ? parameter\n      : typeof parameter === 'string'\n      ? sexp2mic(parameter)\n      : parameter;\n  }\n  return operation;\n};\n\nexport const createSetDelegateOperation = async ({\n  delegate,\n  source,\n  fee = DEFAULT_FEE.DELEGATION,\n  gasLimit = DEFAULT_GAS_LIMIT.DELEGATION,\n  storageLimit = DEFAULT_STORAGE_LIMIT.DELEGATION,\n}: DelegateParams) => {\n  const operation: RPCDelegateOperation = {\n    kind: OpKind.DELEGATION,\n    source,\n    fee,\n    gas_limit: gasLimit,\n    storage_limit: storageLimit,\n    delegate,\n  };\n  return operation;\n};\n\nexport const createRegisterDelegateOperation = async (\n  {\n    fee = DEFAULT_FEE.DELEGATION,\n    gasLimit = DEFAULT_GAS_LIMIT.DELEGATION,\n    storageLimit = DEFAULT_STORAGE_LIMIT.DELEGATION,\n  }: RegisterDelegateParams,\n  source: string\n) => {\n  return {\n    kind: OpKind.DELEGATION,\n    fee,\n    gas_limit: gasLimit,\n    storage_limit: storageLimit,\n    delegate: source,\n  } as RPCDelegateOperation;\n};\n","import { Schema } from '@taquito/michelson-encoder';\nimport BigNumber from 'bignumber.js';\nimport { ContractProvider } from './interface';\n\nexport class BigMapAbstraction {\n  constructor(private id: BigNumber, private schema: Schema, private provider: ContractProvider) {}\n\n  async get(keyToEncode: string) {\n    return this.provider.getBigMapKeyByID(this.id.toString(), keyToEncode, this.schema);\n  }\n\n  toJSON() {\n    return this.id.toString();\n  }\n\n  toString() {\n    return this.id.toString();\n  }\n}\n","import { Schema, Semantic } from '@taquito/michelson-encoder';\nimport { BigMapAbstraction } from './big-map';\nimport { ContractProvider } from './interface';\nimport BigNumber from 'bignumber.js';\nimport { MichelsonV1Expression } from '@taquito/rpc';\n\n// Override the default michelson encoder semantic to provide richer abstraction over storage properties\nexport const smartContractAbstractionSemantic: (p: ContractProvider) => Semantic = (\n  provider: ContractProvider\n) => ({\n  // Provide a specific abstraction for BigMaps\n  big_map: (val: MichelsonV1Expression, code: MichelsonV1Expression) => {\n    if (!val || !('int' in val) || val.int === undefined) {\n      // Return an empty object in case of missing big map ID\n      return {};\n    } else {\n      const schema = new Schema(code);\n      return new BigMapAbstraction(new BigNumber(val.int), schema, provider);\n    }\n  },\n  /*\n  // TODO: embed useful other abstractions\n  'contract':  () => {},\n  'address':  () => {}\n  */\n});\n","import { Schema } from '@taquito/michelson-encoder';\nimport { ScriptResponse } from '@taquito/rpc';\nimport { encodeExpr } from '@taquito/utils';\nimport { Context } from '../context';\nimport { DelegateOperation } from '../operations/delegate-operation';\nimport { OperationEmitter } from '../operations/operation-emitter';\nimport { OriginationOperation } from '../operations/origination-operation';\nimport { TransactionOperation } from '../operations/transaction-operation';\nimport {\n  DelegateParams,\n  OriginateParams,\n  RegisterDelegateParams,\n  TransferParams,\n} from '../operations/types';\nimport { Contract } from './contract';\nimport { InvalidDelegationSource } from './errors';\nimport { ContractProvider, ContractSchema, EstimationProvider } from './interface';\nimport {\n  createOriginationOperation,\n  createRegisterDelegateOperation,\n  createSetDelegateOperation,\n  createTransferOperation,\n} from './prepare';\nimport { smartContractAbstractionSemantic } from './semantic';\n\nexport class RpcContractProvider extends OperationEmitter implements ContractProvider {\n  constructor(context: Context, private estimator: EstimationProvider) {\n    super(context);\n  }\n\n  /**\n   *\n   * @description Return a well formatted json object of the contract storage\n   *\n   * @param contract contract address you want to get the storage from\n   * @param schema optional schema can either be the contract script rpc response or a michelson-encoder schema\n   *\n   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-script\n   */\n  async getStorage<T>(contract: string, schema?: ContractSchema): Promise<T> {\n    if (!schema) {\n      schema = await this.rpc.getScript(contract);\n    }\n\n    let contractSchema: Schema;\n    if (schema instanceof Schema) {\n      contractSchema = schema;\n    } else {\n      contractSchema = Schema.fromRPCResponse({ script: schema as ScriptResponse });\n    }\n\n    const storage = await this.rpc.getStorage(contract);\n\n    return contractSchema.Execute(storage, smartContractAbstractionSemantic(this)) as T; // Cast into T because only the caller can know the true type of the storage\n  }\n\n  /**\n   *\n   * @description Return a well formatted json object of the contract big map storage\n   *\n   * @param contract contract address you want to get the storage from\n   * @param key contract big map key to fetch value from\n   * @param schema optional schema can either be the contract script rpc response or a michelson-encoder schema\n   *\n   * @deprecated Deprecated in favor of getBigMapKeyByID\n   *\n   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-script\n   */\n  async getBigMapKey<T>(contract: string, key: string, schema?: ContractSchema): Promise<T> {\n    if (!schema) {\n      schema = await this.rpc.getScript(contract);\n    }\n\n    let contractSchema: Schema;\n    if (schema instanceof Schema) {\n      contractSchema = schema;\n    } else {\n      contractSchema = Schema.fromRPCResponse({ script: schema as ScriptResponse });\n    }\n\n    const encodedKey = contractSchema.EncodeBigMapKey(key);\n\n    const val = await this.rpc.getBigMapKey(contract, encodedKey);\n\n    return contractSchema.ExecuteOnBigMapValue(val) as T; // Cast into T because only the caller can know the true type of the storage\n  }\n\n  /**\n   *\n   * @description Return a well formatted json object of a big map value\n   *\n   * @param id Big Map ID\n   * @param keyToEncode key to query (will be encoded properly according to the schema)\n   * @param schema Big Map schema (can be determined using your contract type)\n   *\n   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-big-maps-big-map-id-script-expr\n   */\n  async getBigMapKeyByID<T>(id: string, keyToEncode: string, schema: Schema): Promise<T> {\n    const { key, type } = schema.EncodeBigMapKey(keyToEncode);\n    const { packed } = await this.context.rpc.packData({ data: key, type });\n\n    const encodedExpr = encodeExpr(packed);\n\n    const bigMapValue = await this.context.rpc.getBigMapExpr(id.toString(), encodedExpr);\n\n    return schema.ExecuteOnBigMapValue(bigMapValue, smartContractAbstractionSemantic(this)) as T;\n  }\n\n  /**\n   *\n   * @description Originate a new contract according to the script in parameters. Will sign and inject an operation using the current context\n   *\n   * @returns An operation handle with the result from the rpc node\n   *\n   * @warn You cannot specify storage and init at the same time (use init to pass the raw michelson representation of storage)\n   *\n   * @param OriginationOperation Originate operation parameter\n   */\n  async originate(params: OriginateParams) {\n    const estimate = await this.estimate(params, this.estimator.originate.bind(this.estimator));\n\n    const publicKeyHash = await this.signer.publicKeyHash();\n    const operation = await createOriginationOperation({\n      ...params,\n      ...estimate,\n    });\n    const preparedOrigination = await this.prepareOperation({ operation, source: publicKeyHash });\n    const forgedOrigination = await this.forge(preparedOrigination);\n    const { hash, context, forgedBytes, opResponse } = await this.signAndInject(forgedOrigination);\n    return new OriginationOperation(hash, operation, forgedBytes, opResponse, context, this);\n  }\n\n  /**\n   *\n   * @description Set the delegate for a contract. Will sign and inject an operation using the current context\n   *\n   * @returns An operation handle with the result from the rpc node\n   *\n   * @param SetDelegate operation parameter\n   */\n  async setDelegate(params: DelegateParams) {\n    // Since babylon delegation source cannot smart contract\n    if (/kt1/i.test(params.source)) {\n      throw new InvalidDelegationSource(params.source);\n    }\n\n    const estimate = await this.estimate(params, this.estimator.setDelegate.bind(this.estimator));\n    const operation = await createSetDelegateOperation({ ...params, ...estimate });\n    const sourceOrDefault = params.source || (await this.signer.publicKeyHash());\n    const opBytes = await this.prepareAndForge({\n      operation,\n      source: sourceOrDefault,\n    });\n    const { hash, context, forgedBytes, opResponse } = await this.signAndInject(opBytes);\n    return new DelegateOperation(\n      hash,\n      operation,\n      sourceOrDefault,\n      forgedBytes,\n      opResponse,\n      context\n    );\n  }\n\n  /**\n   *\n   * @description Register the current address as delegate. Will sign and inject an operation using the current context\n   *\n   * @returns An operation handle with the result from the rpc node\n   *\n   * @param RegisterDelegate operation parameter\n   */\n  async registerDelegate(params: RegisterDelegateParams) {\n    const estimate = await this.estimate(\n      params,\n      this.estimator.registerDelegate.bind(this.estimator)\n    );\n    const source = await this.signer.publicKeyHash();\n    const operation = await createRegisterDelegateOperation({ ...params, ...estimate }, source);\n    const opBytes = await this.prepareAndForge({ operation });\n    const { hash, context, forgedBytes, opResponse } = await this.signAndInject(opBytes);\n    return new DelegateOperation(hash, operation, source, forgedBytes, opResponse, context);\n  }\n\n  /**\n   *\n   * @description Transfer tz from current address to a specific address. Will sign and inject an operation using the current context\n   *\n   * @returns An operation handle with the result from the rpc node\n   *\n   * @param Transfer operation parameter\n   */\n  async transfer(params: TransferParams) {\n    const estimate = await this.estimate(params, this.estimator.transfer.bind(this.estimator));\n    const operation = await createTransferOperation({\n      ...params,\n      ...estimate,\n    });\n    const source = params.source || (await this.signer.publicKeyHash());\n    const opBytes = await this.prepareAndForge({ operation, source: params.source });\n    const { hash, context, forgedBytes, opResponse } = await this.signAndInject(opBytes);\n    return new TransactionOperation(hash, operation, source, forgedBytes, opResponse, context);\n  }\n\n  async at(address: string): Promise<Contract> {\n    const script = await this.rpc.getScript(address);\n    const entrypoints = await this.rpc.getEntrypoints(address);\n    return new Contract(address, script, this, entrypoints);\n  }\n}\n","const MINIMAL_FEE_MUTEZ = 100;\nconst MINIMAL_FEE_PER_BYTE_MUTEZ = 1;\nconst MINIMAL_FEE_PER_STORAGE_BYTE_MUTEZ = 1000;\nconst MINIMAL_FEE_PER_GAS_MUTEZ = 0.1;\n\nconst GAS_BUFFER = 100;\n\nexport class Estimate {\n  constructor(\n    private readonly _gasLimit: number | string,\n    private readonly _storageLimit: number | string,\n    private readonly opSize: number | string,\n    /**\n     * @description Base fee in mutez (1 mutez = 1e106 tez)\n     */\n    private readonly baseFeeMutez: number | string = MINIMAL_FEE_MUTEZ\n  ) {}\n\n  /**\n   * @description Burn fee in mutez\n   */\n  get burnFeeMutez() {\n    return this.roundUp(Number(this.storageLimit) * MINIMAL_FEE_PER_STORAGE_BYTE_MUTEZ);\n  }\n\n  /**\n   * @description Get the estimated storage limit\n   */\n  get storageLimit() {\n    const limit = Math.max(Number(this._storageLimit), 0);\n    return limit > 0 ? limit : 0;\n  }\n\n  /**\n   * @description Suggested gasLimit for operation\n   */\n  get gasLimit() {\n    return Number(this._gasLimit) + GAS_BUFFER;\n  }\n\n  private get operationFeeMutez() {\n    return (\n      this.gasLimit * MINIMAL_FEE_PER_GAS_MUTEZ + Number(this.opSize) * MINIMAL_FEE_PER_BYTE_MUTEZ\n    );\n  }\n\n  private roundUp(nanotez: number) {\n    return Math.ceil(Number(nanotez));\n  }\n\n  /**\n   * @description Minimum fees for operation according to baker defaults\n   */\n  get minimalFeeMutez() {\n    return this.roundUp(MINIMAL_FEE_MUTEZ + this.operationFeeMutez);\n  }\n\n  /**\n   * @description Suggested fee for operation (minimal fees plus a small buffer)\n   */\n  get suggestedFeeMutez() {\n    return this.roundUp(this.operationFeeMutez + MINIMAL_FEE_MUTEZ * 2);\n  }\n\n  /**\n   * @description Fees according to your specified base fee will ensure that at least minimum fees are used\n   */\n  get usingBaseFeeMutez() {\n    return (\n      Math.max(Number(this.baseFeeMutez), MINIMAL_FEE_MUTEZ) + this.roundUp(this.operationFeeMutez)\n    );\n  }\n\n  get totalCost() {\n    return this.minimalFeeMutez + this.burnFeeMutez;\n  }\n}\n","import { PreapplyResponse, RPCRunOperationParam, OpKind } from '@taquito/rpc';\nimport BigNumber from 'bignumber.js';\nimport { OperationEmitter } from '../operations/operation-emitter';\nimport {\n  flattenErrors,\n  flattenOperationResult,\n  TezosOperationError,\n} from '../operations/operation-errors';\nimport {\n  DelegateParams,\n  isOpWithFee,\n  OriginateParams,\n  ParamsWithKind,\n  PrepareOperationParams,\n  RegisterDelegateParams,\n  RPCOperation,\n  TransferParams,\n} from '../operations/types';\nimport { Estimate } from './estimate';\nimport { EstimationProvider } from './interface';\nimport {\n  createOriginationOperation,\n  createRegisterDelegateOperation,\n  createSetDelegateOperation,\n  createTransferOperation,\n} from './prepare';\n\n// RPC require a signature but do not verify it\nconst SIGNATURE_STUB =\n  'edsigtkpiSSschcaCt9pUVrpNPf7TTcgvgDEDD6NCEHMy8NNQJCGnMfLZzYoQj74yLjo9wx6MPVV29CvVzgi7qEcEUok3k7AuMg';\n\nexport class RPCEstimateProvider extends OperationEmitter implements EstimationProvider {\n  private readonly ALLOCATION_STORAGE = 257;\n  private readonly ORIGINATION_STORAGE = 257;\n\n  // Maximum values defined by the protocol\n  private async getAccountLimits(pkh: string) {\n    const balance = await this.rpc.getBalance(pkh);\n    const {\n      hard_gas_limit_per_operation,\n      hard_storage_limit_per_operation,\n      cost_per_byte,\n    } = await this.rpc.getConstants();\n    return {\n      fee: 0,\n      gasLimit: hard_gas_limit_per_operation.toNumber(),\n      storageLimit: Math.floor(\n        BigNumber.min(balance.dividedBy(cost_per_byte), hard_storage_limit_per_operation).toNumber()\n      ),\n    };\n  }\n\n  private createEstimateFromOperationContent(\n    content: PreapplyResponse['contents'][0],\n    size: number\n  ) {\n    const operationResults = flattenOperationResult({ contents: [content] });\n    let totalGas = 0;\n    let totalStorage = 0;\n    operationResults.forEach(result => {\n      totalStorage +=\n        'originated_contracts' in result && typeof result.originated_contracts !== 'undefined'\n          ? result.originated_contracts.length * this.ORIGINATION_STORAGE\n          : 0;\n      totalStorage += 'allocated_destination_contract' in result ? this.ALLOCATION_STORAGE : 0;\n      totalGas += Number(result.consumed_gas) || 0;\n      totalStorage +=\n        'paid_storage_size_diff' in result ? Number(result.paid_storage_size_diff) || 0 : 0;\n    });\n\n    if (isOpWithFee(content)) {\n      return new Estimate(totalGas || 0, Number(totalStorage || 0), size);\n    } else {\n      return new Estimate(0, 0, size, 0);\n    }\n  }\n\n  private async createEstimate(params: PrepareOperationParams) {\n    const {\n      opbytes,\n      opOb: { branch, contents },\n    } = await this.prepareAndForge(params);\n\n    let operation: RPCRunOperationParam = {\n      operation: { branch, contents, signature: SIGNATURE_STUB },\n      chain_id: await this.rpc.getChainId(),\n    };\n\n    const { opResponse } = await this.simulate(operation);\n\n    const errors = [...flattenErrors(opResponse, 'backtracked'), ...flattenErrors(opResponse)];\n\n    // Fail early in case of errors\n    if (errors.length) {\n      throw new TezosOperationError(errors);\n    }\n\n    while (\n      opResponse.contents.length !== (Array.isArray(params.operation) ? params.operation.length : 1)\n    ) {\n      opResponse.contents.shift();\n    }\n\n    return opResponse.contents.map(x => {\n      return this.createEstimateFromOperationContent(\n        x,\n        opbytes.length / 2 / opResponse.contents.length\n      );\n    });\n  }\n\n  /**\n   *\n   * @description Estimate gasLimit, storageLimit and fees for an origination operation\n   *\n   * @returns An estimation of gasLimit, storageLimit and fees for the operation\n   *\n   * @param OriginationOperation Originate operation parameter\n   */\n  async originate({ fee, storageLimit, gasLimit, ...rest }: OriginateParams) {\n    const pkh = await this.signer.publicKeyHash();\n    const DEFAULT_PARAMS = await this.getAccountLimits(pkh);\n    const op = await createOriginationOperation({\n      ...rest,\n      ...DEFAULT_PARAMS,\n    });\n    return (await this.createEstimate({ operation: op, source: pkh }))[0];\n  }\n  /**\n   *\n   * @description Estimate gasLimit, storageLimit and fees for an transfer operation\n   *\n   * @returns An estimation of gasLimit, storageLimit and fees for the operation\n   *\n   * @param TransferOperation Originate operation parameter\n   */\n  async transfer({ fee, storageLimit, gasLimit, ...rest }: TransferParams) {\n    const pkh = await this.signer.publicKeyHash();\n    const DEFAULT_PARAMS = await this.getAccountLimits(pkh);\n    const op = await createTransferOperation({\n      ...rest,\n      ...DEFAULT_PARAMS,\n    });\n    return (await this.createEstimate({ operation: op, source: pkh }))[0];\n  }\n\n  /**\n   *\n   * @description Estimate gasLimit, storageLimit and fees for a delegate operation\n   *\n   * @returns An estimation of gasLimit, storageLimit and fees for the operation\n   *\n   * @param Estimate\n   */\n  async setDelegate(params: DelegateParams) {\n    const sourceOrDefault = params.source || (await this.signer.publicKeyHash());\n    const DEFAULT_PARAMS = await this.getAccountLimits(sourceOrDefault);\n    const op = await createSetDelegateOperation({ ...params, ...DEFAULT_PARAMS });\n    return (await this.createEstimate({ operation: op, source: sourceOrDefault }))[0];\n  }\n\n  async batch(params: ParamsWithKind[]) {\n    const operations: RPCOperation[] = [];\n    const DEFAULT_PARAMS = await this.getAccountLimits(await this.signer.publicKeyHash());\n    for (const param of params) {\n      switch (param.kind) {\n        case OpKind.TRANSACTION:\n          operations.push(\n            await createTransferOperation({\n              ...param,\n              ...DEFAULT_PARAMS,\n            })\n          );\n          break;\n        case OpKind.ORIGINATION:\n          operations.push(\n            await createOriginationOperation({\n              ...param,\n              ...DEFAULT_PARAMS,\n            })\n          );\n          break;\n        case OpKind.DELEGATION:\n          operations.push(\n            await createSetDelegateOperation({\n              ...param,\n              ...DEFAULT_PARAMS,\n            })\n          );\n          break;\n        case OpKind.ACTIVATION:\n          operations.push({\n            ...param,\n            ...DEFAULT_PARAMS,\n          });\n          break;\n        default:\n          throw new Error(`Unsupported operation kind: ${(param as any).kind}`);\n      }\n    }\n    return this.createEstimate({ operation: operations });\n  }\n\n  /**\n   *\n   * @description Estimate gasLimit, storageLimit and fees for a delegate operation\n   *\n   * @returns An estimation of gasLimit, storageLimit and fees for the operation\n   *\n   * @param Estimate\n   */\n  async registerDelegate(params: RegisterDelegateParams) {\n    const DEFAULT_PARAMS = await this.getAccountLimits(await this.signer.publicKeyHash());\n    const op = await createRegisterDelegateOperation(\n      { ...params, ...DEFAULT_PARAMS },\n      await this.signer.publicKeyHash()\n    );\n    return (\n      await this.createEstimate({ operation: op, source: await this.signer.publicKeyHash() })\n    )[0];\n  }\n}\n","import { OpFilter, FilterExpression, Filter, OpHashFilter, SourceFilter, KindFilter, DestinationFilter, OperationContent } from './interface';\n\nconst opHashFilter = (op: OperationContent, filter: OpHashFilter) => op.hash === filter.opHash;\n\nconst sourceFilter = (x: OperationContent, filter: SourceFilter) => {\n  switch (x.kind) {\n    case 'endorsement':\n      return 'metadata' in x && x.metadata.delegate === filter.source\n    case 'activate_account':\n      return 'metadata' in x && x.pkh === filter.source\n    default:\n      return 'source' in x && x.source === filter.source\n  }\n}\n\nconst kindFilter = (x: OperationContent, filter: KindFilter) => 'kind' in x && x.kind === filter.kind;\n\nconst destinationFilter = (x: OperationContent, filter: DestinationFilter) => {\n  switch (x.kind) {\n    case 'delegation':\n      return x.delegate === filter.destination;\n    case 'origination':\n      if (\n        'metadata' in x &&\n        'operation_result' in x.metadata &&\n        'originated_contracts' in x.metadata.operation_result &&\n        Array.isArray(x.metadata.operation_result.originated_contracts)\n      ) {\n        return x.metadata.operation_result.originated_contracts.some(\n          contract => contract === filter.destination\n        );\n      }\n      break;\n    case 'transaction':\n      return x.destination === filter.destination;\n    default:\n      return false;\n  }\n};\n\nexport const evaluateOpFilter = (op: OperationContent, filter: OpFilter) => {\n  if ('opHash' in filter) {\n    return opHashFilter(op, filter);\n  } else if ('source' in filter) {\n    return sourceFilter(op, filter)\n  } else if ('kind' in filter) {\n    return kindFilter(op, filter);\n  } else if ('destination' in filter) {\n    return destinationFilter(op, filter)\n  }\n\n  return false;\n};\n\nexport const evaluateExpression = (op: OperationContent, exp: FilterExpression): boolean => {\n  if (Array.isArray(exp.and)) {\n    return exp.and.every((x: OpFilter | FilterExpression) => evaluateFilter(op, x));\n  } else if (Array.isArray(exp.or)) {\n    return exp.or.some((x: OpFilter | FilterExpression) => evaluateFilter(op, x));\n  } else {\n    throw new Error('Filter expression must contains either and/or property');\n  }\n};\n\nexport const evaluateFilter = (op: OperationContent, filter: Filter): boolean => {\n  const filters: OpFilter[] | FilterExpression[] = [];\n  if (!Array.isArray(filter)) {\n    filters.push(filter as any);\n  } else {\n    filters.push(...(filter as any));\n  }\n\n  return filters.every((filterOrExp: OpFilter | FilterExpression) => {\n    if ('and' in filterOrExp || 'or' in filterOrExp) {\n      return evaluateExpression(op, filterOrExp);\n    } else {\n      return evaluateOpFilter(op, filterOrExp as OpFilter);\n    }\n  });\n};\n","import { Observable, Subscription as RXJSSubscription, Subject } from 'rxjs';\nimport { Subscription } from './interface';\nimport { takeUntil } from 'rxjs/operators';\n\nexport class ObservableSubscription<T> implements Subscription<T> {\n  private errorListeners: Array<(error: Error) => void> = [];\n  private messageListeners: Array<(data: T) => void> = [];\n  private closeListeners: Array<() => void> = [];\n  private completed$ = new Subject();\n\n  constructor(obs: Observable<T>) {\n    obs.pipe(takeUntil(this.completed$)).subscribe(\n      (data: T) => {\n        this.call(this.messageListeners, data);\n      },\n      error => {\n        this.call(this.errorListeners, error);\n      },\n      () => {\n        this.call(this.closeListeners);\n      }\n    );\n  }\n\n  private call<K>(listeners: Array<(val: K) => void>, value?: K) {\n    for (const l of listeners) {\n      try {\n        l(value!);\n      } catch (ex) {\n        console.error(ex);\n      }\n    }\n  }\n\n  private remove(listeners: Array<any>, value: any) {\n    const idx = listeners.indexOf(value);\n    if (idx !== -1) {\n      listeners.splice(idx, 1);\n    }\n  }\n\n  public on(type: 'error', cb: (error: Error) => void): void;\n  // tslint:disable-next-line: unified-signatures\n  public on(type: 'data', cb: (data: T) => void): void;\n  public on(type: 'close', cb: () => void): void;\n\n  public on(type: 'data' | 'error' | 'close', cb: any): void {\n    switch (type) {\n      case 'data':\n        this.messageListeners.push(cb);\n        break;\n      case 'error':\n        this.errorListeners.push(cb);\n        break;\n      case 'close':\n        this.closeListeners.push(cb);\n        break;\n      default:\n        throw new Error(`Trying to register on an unsupported event: ${type}`);\n    }\n  }\n\n  public off(type: 'error', cb: (error: Error) => void): void;\n  // tslint:disable-next-line: unified-signatures\n  public off(type: 'data', cb: (data: T) => void): void;\n  public off(type: 'close', cb: () => void): void;\n\n  public off(type: 'data' | 'error' | 'close', cb: any): void {\n    switch (type) {\n      case 'data':\n        this.remove(this.messageListeners, cb);\n        break;\n      case 'error':\n        this.remove(this.errorListeners, cb);\n        break;\n      case 'close':\n        this.remove(this.closeListeners, cb);\n        break;\n      default:\n        throw new Error(`Trying to unregister on an unsupported event: ${type}`);\n    }\n  }\n\n  public close() {\n    this.completed$.next();\n  }\n}\n","import { BlockResponse, OperationEntry } from '@taquito/rpc';\nimport { from, Observable, ObservableInput, timer } from 'rxjs';\nimport {\n  concatMap,\n  distinctUntilKeyChanged,\n  first,\n  map,\n  pluck,\n  publishReplay,\n  refCount,\n  switchMap,\n} from 'rxjs/operators';\nimport { Context } from '../context';\nimport { evaluateFilter } from './filters';\nimport { Filter, SubscribeProvider, Subscription, OperationContent } from './interface';\nimport { ObservableSubscription } from './observable-subscription';\n\nconst getLastBlock = (context: Context) => {\n  return from(context.rpc.getBlock()).pipe(first());\n};\n\nconst applyFilter = (filter: Filter) =>\n  concatMap<BlockResponse, ObservableInput<OperationContent>>(block => {\n    return new Observable<OperationContent>(sub => {\n      for (const ops of block.operations) {\n        for (const op of ops) {\n          for (const content of op.contents) {\n            if (evaluateFilter({hash: op.hash, ...content}, filter)) {\n              sub.next({hash: op.hash, ...content});\n            }\n          }\n        }\n      }\n      sub.complete();\n    });\n  });\n\nexport class PollingSubscribeProvider implements SubscribeProvider {\n  private newBlock$ = timer(0, this.POLL_INTERVAL).pipe(\n    map(() => this.context),\n    switchMap(getLastBlock),\n    distinctUntilKeyChanged('hash'),\n    publishReplay(),\n    refCount()\n  );\n\n  constructor(private context: Context, public readonly POLL_INTERVAL = 20000) {}\n\n  subscribe(_filter: 'head'): Subscription<string> {\n    return new ObservableSubscription(this.newBlock$.pipe(pluck('hash')));\n  }\n\n  subscribeOperation(filter: Filter): Subscription<OperationContent> {\n    return new ObservableSubscription(this.newBlock$.pipe(applyFilter(filter)));\n  }\n}\n","import BigNumber from 'bignumber.js';\nimport { Context } from '../context';\nimport { OperationEmitter } from '../operations/operation-emitter';\nimport { Operation } from '../operations/operations';\nimport { RPCActivateOperation } from '../operations/types';\nimport { TzProvider } from './interface';\nimport { OpKind } from '@taquito/rpc';\n\nexport class RpcTzProvider extends OperationEmitter implements TzProvider {\n  constructor(context: Context) {\n    super(context);\n  }\n\n  async getBalance(address: string): Promise<BigNumber> {\n    return this.rpc.getBalance(address);\n  }\n\n  async getDelegate(address: string): Promise<string | null> {\n    return this.rpc.getDelegate(address);\n  }\n\n  async activate(pkh: string, secret: string) {\n    const operation: RPCActivateOperation = {\n      kind: OpKind.ACTIVATION,\n      pkh,\n      secret,\n    };\n\n    const forgedBytes = await this.prepareAndForge({ operation: [operation], source: pkh });\n    const bytes = `${forgedBytes.opbytes}00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000`;\n    return new Operation(\n      await this.rpc.injectOperation(bytes),\n      { ...forgedBytes, opbytes: bytes },\n      [],\n      this.context.clone()\n    );\n  }\n}\n","import {\n  RPCOperation,\n  GasConsumingOperation,\n  StorageConsumingOperation,\n  FeeConsumingOperation,\n  ForgedBytes,\n} from './types';\nimport { Operation } from './operations';\nimport { OperationContentsAndResult } from '@taquito/rpc';\nimport { Context } from '../context';\nimport { flattenOperationResult, flattenErrors } from './operation-errors';\n\nexport class BatchOperation extends Operation\n  implements GasConsumingOperation, StorageConsumingOperation, FeeConsumingOperation {\n  constructor(\n    hash: string,\n    private readonly params: RPCOperation[],\n    public readonly source: string,\n    raw: ForgedBytes,\n    results: OperationContentsAndResult[],\n    context: Context\n  ) {\n    super(hash, raw, results, context);\n  }\n\n  private sumProp(arr: any[], prop: string) {\n    return arr.reduce((prev, current) => {\n      return prop in current ? Number(current[prop]) + prev : prev;\n    }, 0);\n  }\n\n  get fee() {\n    return this.sumProp(this.params, 'fee');\n  }\n\n  get gasLimit() {\n    return this.sumProp(this.params, 'gas_limit');\n  }\n\n  get storageLimit() {\n    return this.sumProp(this.params, 'storage_limit');\n  }\n\n  get consumedGas() {\n    return String(this.sumProp(flattenOperationResult({ contents: this.results }), 'consumed_gas'));\n  }\n\n  get storageDiff() {\n    return String(\n      this.sumProp(flattenOperationResult({ contents: this.results }), 'paid_storage_size_diff')\n    );\n  }\n\n  get errors() {\n    return flattenErrors({ contents: this.results });\n  }\n}\n","import { Context } from '../context';\nimport { ContractMethod } from '../contract/contract';\nimport { EstimationProvider } from '../contract/interface';\nimport {\n  createOriginationOperation,\n  createSetDelegateOperation,\n  createTransferOperation,\n} from '../contract/prepare';\nimport { BatchOperation } from '../operations/batch-operation';\nimport { OperationEmitter } from '../operations/operation-emitter';\nimport {\n  ActivationParams,\n  DelegateParams,\n  OriginateParams,\n  RPCOperation,\n  TransferParams,\n  ParamsWithKind,\n  isOpWithFee,\n} from '../operations/types';\nimport { OpKind } from '@taquito/rpc';\n\nexport class OperationBatch extends OperationEmitter {\n  private operations: ParamsWithKind[] = [];\n\n  constructor(context: Context, private estimator: EstimationProvider) {\n    super(context);\n  }\n\n  /**\n   *\n   * @description Add a transaction operation to the batch\n   *\n   * @param params Transfer operation parameter\n   */\n  withTransfer(params: TransferParams) {\n    this.operations.push({ kind: OpKind.TRANSACTION, ...params });\n    return this;\n  }\n\n  /**\n   *\n   * @description Add a transaction operation to the batch\n   *\n   * @param params Transfer operation parameter\n   */\n  withContractCall(params: ContractMethod) {\n    return this.withTransfer(params.toTransferParams());\n  }\n\n  /**\n   *\n   * @description Add a delegation operation to the batch\n   *\n   * @param params Delegation operation parameter\n   */\n  withDelegation(params: DelegateParams) {\n    this.operations.push({ kind: OpKind.DELEGATION, ...params });\n    return this;\n  }\n\n  /**\n   *\n   * @description Add an activation operation to the batch\n   *\n   * @param params Activation operation parameter\n   */\n  withActivation({ pkh, secret }: ActivationParams) {\n    this.operations.push({ kind: OpKind.ACTIVATION, pkh, secret });\n    return this;\n  }\n\n  /**\n   *\n   * @description Add an origination operation to the batch\n   *\n   * @param params Origination operation parameter\n   */\n  withOrigination(params: OriginateParams) {\n    this.operations.push({ kind: OpKind.ORIGINATION, ...params });\n    return this;\n  }\n\n  private async getRPCOp(param: ParamsWithKind) {\n    switch (param.kind) {\n      case OpKind.TRANSACTION:\n        return createTransferOperation({\n          ...param,\n        });\n      case OpKind.ORIGINATION:\n        return createOriginationOperation({\n          ...param,\n        });\n      case OpKind.DELEGATION:\n        return createSetDelegateOperation({\n          ...param,\n        });\n      case OpKind.ACTIVATION:\n        return {\n          ...param,\n        };\n      default:\n        throw new Error(`Unsupported operation kind: ${(param as any).kind}`);\n    }\n  }\n\n  /**\n   *\n   * @description Add a group operation to the batch. Operation will be applied in the order they are in the params array\n   *\n   * @param params Operations parameter\n   */\n  with(params: ParamsWithKind[]) {\n    for (const param of params) {\n      switch (param.kind) {\n        case OpKind.TRANSACTION:\n          this.withTransfer(param);\n          break;\n        case OpKind.ORIGINATION:\n          this.withOrigination(param);\n          break;\n        case OpKind.DELEGATION:\n          this.withDelegation(param);\n          break;\n        case OpKind.ACTIVATION:\n          this.withActivation(param);\n          break;\n        default:\n          throw new Error(`Unsupported operation kind: ${(param as any).kind}`);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   *\n   * @description Forge and Inject the operation batch\n   *\n   * @param params Optionally specify the source of the operation\n   */\n  async send(params?: { source?: string }) {\n    const estimates = await this.estimator.batch(this.operations);\n    const ops: RPCOperation[] = [];\n    let i = 0;\n    for (const op of this.operations) {\n      if (isOpWithFee(op)) {\n        const estimated = await this.estimate(op, async () => estimates[i]);\n        ops.push(await this.getRPCOp({ ...op, ...estimated }));\n      } else {\n        ops.push({ ...op });\n      }\n      i++;\n    }\n    const source = (params && params.source) || (await this.signer.publicKeyHash());\n    const opBytes = await this.prepareAndForge({\n      operation: ops,\n      source,\n    });\n    const { hash, context, forgedBytes, opResponse } = await this.signAndInject(opBytes);\n    return new BatchOperation(hash, ops, source, forgedBytes, opResponse, context);\n  }\n}\n\nexport class RPCBatchProvider {\n  constructor(private context: Context, private estimator: EstimationProvider) {}\n\n  /***\n   *\n   * @description Batch a group of operation together. Operations will be applied in the order in which they are added to the batch\n   *\n   * @param params List of operation to batch together\n   */\n  batch(params?: ParamsWithKind[]) {\n    const batch = new OperationBatch(this.context, this.estimator);\n\n    if (Array.isArray(params)) {\n      batch.with(params);\n    }\n\n    return batch;\n  }\n}\n","const setDelegate = (key: string) => {\n  return [\n    { prim: 'DROP' },\n    { prim: 'NIL', args: [{ prim: 'operation' }] },\n    {\n      prim: 'PUSH',\n      args: [{ prim: 'key_hash' }, { string: key }],\n    },\n    { prim: 'SOME' },\n    { prim: 'SET_DELEGATE' },\n    { prim: 'CONS' },\n  ];\n};\n\nconst transferImplicit = (key: string, mutez: number) => {\n  return [\n    { prim: 'DROP' },\n    { prim: 'NIL', args: [{ prim: 'operation' }] },\n    {\n      prim: 'PUSH',\n      args: [{ prim: 'key_hash' }, { string: key }],\n    },\n    { prim: 'IMPLICIT_ACCOUNT' },\n    {\n      prim: 'PUSH',\n      args: [{ prim: 'mutez' }, { int: `${mutez}` }],\n    },\n    { prim: 'UNIT' },\n    { prim: 'TRANSFER_TOKENS' },\n    { prim: 'CONS' },\n  ];\n};\n\nconst removeDelegate = () => {\n  return [\n    { prim: 'DROP' },\n    { prim: 'NIL', args: [{ prim: 'operation' }] },\n    { prim: 'NONE', args: [{ prim: 'key_hash' }] },\n    { prim: 'SET_DELEGATE' },\n    { prim: 'CONS' },\n  ];\n};\n\nconst transferToContract = (key: string, amount: number) => {\n  return [\n    { prim: 'DROP' },\n    { prim: 'NIL', args: [{ prim: 'operation' }] },\n    {\n      prim: 'PUSH',\n      args: [{ prim: 'address' }, { string: key }],\n    },\n    { prim: 'CONTRACT', args: [{ prim: 'unit' }] },\n    [\n      {\n        prim: 'IF_NONE',\n        args: [[[{ prim: 'UNIT' }, { prim: 'FAILWITH' }]], []],\n      },\n    ],\n    {\n      prim: 'PUSH',\n      args: [{ prim: 'mutez' }, { int: `${amount}` }],\n    },\n    { prim: 'UNIT' },\n    { prim: 'TRANSFER_TOKENS' },\n    { prim: 'CONS' },\n  ];\n};\n\nexport const MANAGER_LAMBDA = {\n  setDelegate,\n  removeDelegate,\n  transferImplicit,\n  transferToContract,\n};\n","import { Forger, ForgeParams, ForgeResponse } from './interface';\n\nexport class ForgingMismatchError implements Error {\n  name: string = 'ForgingMismatchError';\n  message: string = 'Forging mismatch error';\n  constructor(public results: string[]) {}\n}\n\nexport class CompositeForger implements Forger {\n  constructor(private forgers: Forger[]) {\n    if (forgers.length === 0) {\n      throw new Error('At least one forger must be specified');\n    }\n  }\n\n  async forge({ branch, contents }: ForgeParams): Promise<ForgeResponse> {\n    const results = await Promise.all(\n      this.forgers.map(forger => {\n        return forger.forge({ branch, contents });\n      })\n    );\n\n    if (results.length === 0) {\n      throw new Error('At least one forger must be specified');\n    }\n\n    let lastResult: string = results.pop()!; // Assumed to be more than one since we\n    while (results.length) {\n      const currentResult = results.pop()!;\n\n      if (currentResult !== lastResult) {\n        throw new ForgingMismatchError([lastResult, currentResult]);\n      }\n      lastResult = currentResult;\n    }\n\n    return lastResult;\n  }\n}\n","import { RpcClient } from '@taquito/rpc';\nimport { InMemorySigner } from '@taquito/signer';\nimport { Protocols } from './constants';\nimport { Context, Config, TaquitoProvider } from './context';\nimport { ContractProvider, EstimationProvider } from './contract/interface';\nimport { RpcContractProvider } from './contract/rpc-contract-provider';\nimport { RPCEstimateProvider } from './contract/rpc-estimate-provider';\nimport { format } from './format';\nimport { Signer } from './signer/interface';\nimport { NoopSigner } from './signer/noop';\nimport { SubscribeProvider } from './subscribe/interface';\nimport { PollingSubscribeProvider } from './subscribe/polling-provider';\nimport { TzProvider } from './tz/interface';\nimport { RpcTzProvider } from './tz/rpc-tz-provider';\nimport { Forger } from './forger/interface';\nimport { RpcForger } from './forger/rpc-forger';\nimport { RPCBatchProvider } from './batch/rpc-batch-provider';\n\nexport * from './signer/interface';\nexport * from './subscribe/interface';\nexport * from './forger/interface';\nexport * from './tz/interface';\nexport * from './contract';\nexport * from './contract/big-map';\nexport * from './constants';\n\nexport { OpKind } from './operations/types';\n\nexport { TaquitoProvider } from './context';\nexport { PollingSubscribeProvider } from './subscribe/polling-provider';\nexport { RpcForger } from './forger/rpc-forger';\nexport { CompositeForger } from './forger/composite-forger';\nexport {\n  MichelsonMap,\n  MichelsonMapKey,\n  MapTypecheckError,\n  UnitValue,\n} from '@taquito/michelson-encoder';\n\nexport {\n  TezosOperationError,\n  TezosOperationErrorWithMessage,\n  TezosPreapplyFailureError,\n} from './operations/operation-errors';\n\nexport { SubscribeProvider } from './subscribe/interface';\nexport interface SetProviderOptions {\n  forger?: Forger;\n  rpc?: string | RpcClient;\n  stream?: string | SubscribeProvider;\n  signer?: Signer;\n  protocol?: Protocols;\n  config?: Config;\n}\n\n/**\n * @description Facade class that surfaces all of the libraries capability and allow it's configuration\n */\nexport class TezosToolkit {\n  private _rpcClient = new RpcClient();\n  private _stream!: SubscribeProvider;\n  private _options: SetProviderOptions = {};\n\n  private _context: Context = new Context();\n\n  private _tz = new RpcTzProvider(this._context);\n  private _estimate = new RPCEstimateProvider(this._context);\n  private _contract = new RpcContractProvider(this._context, this._estimate);\n  private _batch = new RPCBatchProvider(this._context, this._estimate);\n\n  public readonly format = format;\n\n  constructor() {\n    this.setProvider({ rpc: this._rpcClient });\n  }\n\n  /**\n   * @description Sets configuration on the Tezos Taquito instance. Allows user to choose which signer, rpc client, rpc url, forger and so forth\n   *\n   * @param options rpc url or rpcClient to use to interact with the Tezos network and  url to use to interact with the Tezos network\n   *\n   * @example Tezos.setProvider({signer: new InMemorySigner(edsk...)})\n   * @example Tezos.setProvider({config: {confirmationPollingTimeoutSecond: 300}})\n   *\n   */\n  setProvider({ rpc, stream, signer, protocol, config, forger }: SetProviderOptions) {\n    this.setRpcProvider(rpc);\n    this.setStreamProvider(stream);\n    this.setSignerProvider(signer);\n    this.setForgerProvider(forger);\n\n    this._context.proto = protocol;\n    this._context.config = config as Required<Config>;\n  }\n\n  private setSignerProvider(signer: SetProviderOptions['signer']) {\n    if (!this._options.signer && typeof signer === 'undefined') {\n      this._context.signer = new NoopSigner();\n      this._options.signer = signer;\n    } else if (typeof signer !== 'undefined') {\n      this._context.signer = signer;\n      this._options.signer = signer;\n    }\n  }\n\n  private setRpcProvider(rpc: SetProviderOptions['rpc']) {\n    if (typeof rpc === 'string') {\n      this._rpcClient = new RpcClient(rpc);\n    } else if (rpc instanceof RpcClient) {\n      this._rpcClient = rpc;\n    } else if (this._options.rpc === undefined) {\n      this._rpcClient = new RpcClient();\n    }\n    this._options.rpc = rpc;\n    this._context.rpc = this._rpcClient;\n  }\n\n  private setForgerProvider(forger: SetProviderOptions['forger']) {\n    const f = typeof forger === 'undefined' ? new RpcForger(this._context) : forger;\n    this._options.forger = f;\n    this._context.forger = f;\n  }\n\n  private setStreamProvider(stream: SetProviderOptions['stream']) {\n    if (typeof stream === 'string') {\n      this._stream = new PollingSubscribeProvider(new Context(new RpcClient(stream)));\n    } else if (typeof stream !== 'undefined') {\n      this._stream = stream;\n    } else if (this._options.stream === undefined) {\n      this._stream = new PollingSubscribeProvider(this._context);\n    }\n    this._options.stream = stream;\n  }\n\n  /**\n   * @description Provide access to tezos account management\n   */\n  get tz(): TzProvider {\n    return this._tz;\n  }\n\n  /**\n   * @description Provide access to smart contract utilities\n   */\n  get contract(): ContractProvider {\n    return this._contract;\n  }\n\n  public batch = this._batch.batch.bind(this._batch);\n\n  /**\n   * @description Provide access to operation estimation utilities\n   */\n  get estimate(): EstimationProvider {\n    return this._estimate;\n  }\n\n  /**\n   * @description Provide access to streaming utilities backed by an streamer implementation\n   */\n  get stream(): SubscribeProvider {\n    return this._stream;\n  }\n\n  /**\n   * @description Provide access to the currently used rpc client\n   */\n  get rpc(): RpcClient {\n    return this._context.rpc;\n  }\n\n  /**\n   * @description Provide access to the currently used signer\n   */\n  get signer() {\n    return this._context.signer;\n  }\n\n  /**\n   *\n   * @description Import a key to sign operation\n   *\n   * @param privateKey Key to load in memory\n   * @param passphrase If the key is encrypted passphrase to decrypt it\n   */\n  importKey(privateKey: string, passphrase?: string): Promise<void>;\n  /**\n   *\n   * @description Import a key using faucet/fundraiser parameter\n   *\n   * @param email Faucet email\n   * @param password Faucet password\n   * @param mnemonic Faucet mnemonic\n   * @param secret Faucet secret\n   */\n  // tslint:disable-next-line: unified-signatures\n  importKey(email: string, password: string, mnemonic: string, secret: string): Promise<void>;\n\n  async importKey(\n    privateKeyOrEmail: string,\n    passphrase?: string,\n    mnemonic?: string,\n    secret?: string\n  ): Promise<void> {\n    if (privateKeyOrEmail && passphrase && mnemonic && secret) {\n      const previousSigner = this.signer;\n      const signer = InMemorySigner.fromFundraiser(privateKeyOrEmail, passphrase, mnemonic);\n      const pkh = await signer.publicKeyHash();\n      this.setSignerProvider(signer);\n      try {\n        let op;\n        try {\n          op = await this.tz.activate(pkh, secret);\n        } catch (ex) {\n          const isInvalidActivationError = ex && ex.body && /Invalid activation/.test(ex.body);\n          if (!isInvalidActivationError) {\n            throw ex;\n          }\n        }\n        if (op) {\n          await op.confirmation();\n        }\n      } catch (ex) {\n        // Restore to previous signer in case of error\n        this.setSignerProvider(previousSigner);\n        throw ex;\n      }\n    } else {\n      // Fallback to regular import\n      this.setSignerProvider(new InMemorySigner(privateKeyOrEmail, passphrase));\n    }\n  }\n\n  getFactory<T, K extends Array<any>>(ctor: TaquitoProvider<T, K>) {\n    return (...args: K) => {\n      return new ctor(this._context, ...args);\n    };\n  }\n}\n\n/**\n * @description Default Tezos toolkit instance\n */\nexport const Tezos = new TezosToolkit();\n"]},"metadata":{},"sourceType":"module"}